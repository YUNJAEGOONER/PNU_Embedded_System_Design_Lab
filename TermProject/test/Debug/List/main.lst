###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       23/Dec/2024  09:12:45
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\pnu8\Desktop\test\user\main.c
#    Command line =  
#        -f C:\Users\pnu8\AppData\Local\Temp\EWAABA.tmp
#        (C:\Users\pnu8\Desktop\test\user\main.c -D USE_STDPERIPH_DRIVER -D
#        STM32F10X_CL -lC C:\Users\pnu8\Desktop\test\Debug\List -o
#        C:\Users\pnu8\Desktop\test\Debug\Obj --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu8\Desktop\test\libraries\CMSIS\DeviceSupport\ -I
#        C:\Users\pnu8\Desktop\test\libraries\CMSIS\DeviceSupport\Startup\ -I
#        C:\Users\pnu8\Desktop\test\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu8\Desktop\test\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu8\Desktop\test\user\ -I
#        C:\Users\pnu8\Desktop\test\user\inc\ -I
#        C:\Users\pnu8\Desktop\test\libraries\LCD\ -Ol -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  C:\Users\pnu8\Desktop\test\Debug\List\main.lst
#    Object file  =  C:\Users\pnu8\Desktop\test\Debug\Obj\main.o
#
###############################################################################

C:\Users\pnu8\Desktop\test\user\main.c
      1          #include <string.h>
      2          #include <stdio.h>
      3          #include <stdint.h>
      4          #include <stdbool.h>
      5          #include "stm32f10x.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000E   0x408A             LSLS     R2,R2,R1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0xe000e100
   \   00000014   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000016   0x0940             LSRS     R0,R0,#+5
   \   00000018   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
      6          #include "misc.h"
      7          #include "stm32f10x_gpio.h"
      8          #include "stm32f10x_rcc.h"
      9          #include "stm32f10x_usart.h"
     10          #include "stm32f10x_adc.h"
     11          #include "stm32f10x_tim.h"
     12          #include "stm32f10x_exti.h"
     13          #include "lcd.h"
     14          #include "touch.h"
     15          #include "core_cm3.h"
     16          
     17          
     18          /*
     19          ===================================================================================
     20                                  ?@@???@@ ?@@ @?@@@@
     21          ===================================================================================
     22          */
     23          #define MAIN_DELAY 100000 // @@@ @@@?@@ ?@@???@@?
     24          #define PUMP_DELAY 20000 // water ?@@ ?@@ ??@@@ @??@@???@@
     25          #define USART2_DELAY 20000
     26          #define USART_DELAY 90000 // usart ?@@???@@ ???@????@@?
     27          #define BUFFER_SIZE 200 // @@@ @@@???@? ?@@ ?@@ 
     28          
     29          #define SERVO_LEFT 500 // ?@@ @@@ ?@@?@@ ?@@@
     30          #define SERVO_RIGHT 2000 // ?@@ @@@ ?@@@@@@??@@@
     31          #define WET_LIMIT 500 // ?@@ ?@@ ?@@ @@@ ??@@@???@@@?@@@??@@@@??@@
     32          #define BRIGHT_LIMIT 1250 // @@@ ?@@ @@@ ??@@@???@@ @@? @@@@??@@
     33          
     34          // @@@???@@
     35          #define SET_MODE_AUTO "mode 1"
     36          #define SET_MODE_MANUAL "mode 0"
     37          #define SET_LED_OFF "led 0"
     38          #define SET_LED_ON "led 1"
     39          #define SET_DOOR_CLOSE "door 0"
     40          #define SET_DOOR_OPEN "door 1"
     41          #define WATERING "water"
     42          
     43          
     44          // @@@@??@@
     45          
     46          // ?@@???@@@??@@@@@ @@??@@ ?@@@?@@@@@@ ?€?@@??@@@@
     47          // isClose : @@@ ?@@@€ @€@@@@€ ?@?
     48          // isEnough : ?@@ ?@@@€ @@@?@? ?@?
     49          // isWet : ?@@ ?@@ ?@@@€ @@@?@? ?@?
     50          typedef struct _SensorState {
     51              bool isClose; bool isEnough; bool isWet; bool isBright;
     52          } SensorState;
     53          
     54          // ?@@???@@??@@@???@@???@@@??€?@@??@@@@
     55          // soilMoisture : ?@@ ?@@ ?@@ @
     56          // light : @@@ ?@@ @
     57          // mode : ?@@ @@@?@? ?@@ @@@?@?
     58          // led : led@€ @@@?@@@€
     59          // door : @@@ ?@@?@@@€
     60          typedef struct _InnerState {
     61              uint16_t soilMoisture; uint16_t light; bool mode; bool led; bool door;
     62          } DeviceState;
     63          
     64          
     65          // @@@ @@@@?- usart, json ?@@?@? ?€?@@??@@@
     66          typedef struct _Buffer {
     67              char mem[BUFFER_SIZE]; uint32_t index;
     68          } Buffer;
     69          
     70          
     71          // USART @@@ ?@@??flag @@@ @€?@@@??@@ ?@@?
     72          typedef enum _USART_DIR { USART1_DIR = 0, USART2_DIR = 1} USART_DIR;
     73          // pump ?@@@??€?@@@??@@ ?@@?
     74          typedef enum _PUMP_STATE { PUMP_OFF = 0, PUMP_ON = 1} PUMP_STATE;
     75          /*
     76          -----------------------------------------------------------------------------------
     77          */
     78          
     79          /*
     80          ===================================================================================
     81                                  ?@@ @€???@@
     82          ===================================================================================
     83          */
     84          
     85          // ?@@???@@ ?@@ @€?

   \                                 In section .bss, align 4
     86          SensorState sensorState;    
   \                     sensorState:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     87          DeviceState deviceState;
   \                     deviceState:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
     88          PUMP_STATE pumpState;
   \                     pumpState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     89          Buffer usart1Buffer; // usart1 @@@
   \                     usart1Buffer:
   \   00000000                      DS8 204

   \                                 In section .bss, align 4
     90          Buffer usart2Buffer; // usart2 @@@
   \                     usart2Buffer:
   \   00000000                      DS8 204

   \                                 In section .bss, align 4
     91          Buffer jsonBuffer; // json ?@@?@? ?€?@@ @@@
   \                     jsonBuffer:
   \   00000000                      DS8 204
     92          
     93          // ?@@?@@???@@??@@@@

   \                                 In section .bss, align 4
     94          GPIO_InitTypeDef GPIO_InitStructure;
   \                     GPIO_InitStructure:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     95          TIM_OCInitTypeDef TIM_OCInitStructure;
   \                     TIM_OCInitStructure:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     96          USART_InitTypeDef USART_InitStructure;
   \                     USART_InitStructure:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     97          ADC_InitTypeDef ADC_InitStructure;
   \                     ADC_InitStructure:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     98          TIM_TimeBaseInitTypeDef TIM_InitStructure;
   \                     TIM_InitStructure:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     99          TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
   \                     TIM_TimeBaseStructure:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
    100          NVIC_InitTypeDef NVIC_InitStructure;
   \                     NVIC_InitStructure:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    101          EXTI_InitTypeDef EXTI_InitStructure;
   \                     EXTI_InitStructure:
   \   00000000                      DS8 8
    102          /*
    103          -----------------------------------------------------------------------------------
    104          */
    105          /*
    106          ===================================================================================
    107                                  ?@@ ?@@
    108          ===================================================================================
    109          */
    110          
    111          void NVIC_Config();
    112          void usart1_config();
    113          void usart2_config();
    114          void adc_module_config();
    115          void servo_config();
    116          void eps32_config();
    117          void pump_config();
    118          void led_config();
    119          void readBuffer(Buffer* buffer, char data);
    120          void resetIndex(Buffer* buffer);
    121          void excuteCommand(USART_DIR which_usart);
    122          void controlServo(uint16_t pulse);
    123          void controlLED(bool on);
    124          void controlPump(bool on);
    125          void water();
    126          void myDelay(uint32_t count);
    127          void sendJsonToUART();
    128          void initialModules();
    129          
    130          /*
    131          ===================================================================================
    132                                  ?@@ @€???@@ ?@@
    133          ===================================================================================
    134          */
    135          
    136          // NVIC ?@@
    137          // NVIC@??@@?@@ @??@@?@@ ?@@?@@@??@@

   \                                 In section .text, align 2, keep-with-next
    138          void NVIC_Config() {
   \                     NVIC_Config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    139              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);
   \   00000002   0xF44F 0x6080      MOV      R0,#+1024
   \   00000006   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    140              /* @@@???@@ ?@@ @@@??@@@?@@ ?@@ */
    141          
    142              // usart1 ?@@?@@ ?@@ - ?@@?@@ 1
    143              NVIC_EnableIRQ(USART1_IRQn);
   \   0000000A   0x2025             MOVS     R0,#+37
   \   0000000C   0x.... 0x....      BL       __NVIC_EnableIRQ
    144              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   00000010   0x2025             MOVS     R0,#+37
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    145              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000001E   0x7048             STRB     R0,[R1, #+1]
    146              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000026   0x7088             STRB     R0,[R1, #+2]
    147              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;    
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000002E   0x70C8             STRB     R0,[R1, #+3]
    148              NVIC_Init(&NVIC_InitStructure);
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000034   0x.... 0x....      BL       NVIC_Init
    149              
    150              // usart2 ?@@?@@ ?@@ - ?@@?@@ 2
    151              NVIC_EnableIRQ(USART2_IRQn);
   \   00000038   0x2026             MOVS     R0,#+38
   \   0000003A   0x.... 0x....      BL       __NVIC_EnableIRQ
    152              NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
   \   0000003E   0x2026             MOVS     R0,#+38
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    153              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000004C   0x7048             STRB     R0,[R1, #+1]
    154              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000054   0x7088             STRB     R0,[R1, #+2]
    155              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000005C   0x70C8             STRB     R0,[R1, #+3]
    156              NVIC_Init(&NVIC_InitStructure);
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000062   0x.... 0x....      BL       NVIC_Init
    157          
    158              // EXTI ?@@?@@ ?@@
    159              // @@@ ?@@ ?@@?@@ ?@@ - pd1 - ?@@?@@ 3
    160              NVIC_EnableIRQ(EXTI1_IRQn);
   \   00000066   0x2007             MOVS     R0,#+7
   \   00000068   0x.... 0x....      BL       __NVIC_EnableIRQ
    161              NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
   \   0000006C   0x2007             MOVS     R0,#+7
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000072   0x7008             STRB     R0,[R1, #+0]
    162              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000007A   0x7048             STRB     R0,[R1, #+1]
    163              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000082   0x7088             STRB     R0,[R1, #+2]
    164              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000008A   0x70C8             STRB     R0,[R1, #+3]
    165              NVIC_Init(&NVIC_InitStructure);
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000090   0x.... 0x....      BL       NVIC_Init
    166              
    167              // ?@@ ?@@ ?@@?@@ ?@@ - pd2 - ?@@?@@ 4
    168              NVIC_EnableIRQ(EXTI2_IRQn);
   \   00000094   0x2008             MOVS     R0,#+8
   \   00000096   0x.... 0x....      BL       __NVIC_EnableIRQ
    169              NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;
   \   0000009A   0x2008             MOVS     R0,#+8
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
    170              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
   \   000000A2   0x2004             MOVS     R0,#+4
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000A8   0x7048             STRB     R0,[R1, #+1]
    171              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000B0   0x7088             STRB     R0,[R1, #+2]
    172              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000B8   0x70C8             STRB     R0,[R1, #+3]
    173              NVIC_Init(&NVIC_InitStructure);
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   000000BE   0x.... 0x....      BL       NVIC_Init
    174          
    175              // TIM2 ?@@?@@ ?@@(@??@@ ?@@?? - ?@@?@@ 5
    176              NVIC_EnableIRQ(TIM2_IRQn);
   \   000000C2   0x201C             MOVS     R0,#+28
   \   000000C4   0x.... 0x....      BL       __NVIC_EnableIRQ
    177              NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
   \   000000C8   0x201C             MOVS     R0,#+28
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
    178              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
   \   000000D0   0x2005             MOVS     R0,#+5
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000D6   0x7048             STRB     R0,[R1, #+1]
    179              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000DE   0x7088             STRB     R0,[R1, #+2]
    180              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000E6   0x70C8             STRB     R0,[R1, #+3]
    181              NVIC_Init(&NVIC_InitStructure);
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   000000EC   0x.... 0x....      BL       NVIC_Init
    182          
    183              // ADC ?@@?@@ ?@@(?@@ ?@@ @? @@@ @? - ?@@?@@ 6
    184              // @@@ ?@@ ?@@ @@@ @@€@@ @@@ @@??@@ ?@@ ?@@?@@@???@ ?@@
    185              NVIC_EnableIRQ(ADC1_2_IRQn);
   \   000000F0   0x2012             MOVS     R0,#+18
   \   000000F2   0x.... 0x....      BL       __NVIC_EnableIRQ
    186              NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQn;
   \   000000F6   0x2012             MOVS     R0,#+18
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000FC   0x7008             STRB     R0,[R1, #+0]
    187              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 6;  
   \   000000FE   0x2006             MOVS     R0,#+6
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000104   0x7048             STRB     R0,[R1, #+1]
    188              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000010C   0x7088             STRB     R0,[R1, #+2]
    189              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000114   0x70C8             STRB     R0,[R1, #+3]
    190              NVIC_Init(&NVIC_InitStructure);
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000011A   0x.... 0x....      BL       NVIC_Init
    191          }
   \   0000011E   0xBD01             POP      {R0,PC}          ;; return
    192          
    193          // USART1 ?@@
    194          // PA9 - TX - esp32 d16
    195          // PA10 - RX = esp32 d17
    196          

   \                                 In section .text, align 2, keep-with-next
    197          void usart1_config() {
   \                     usart1_config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    198              // ?@@ ?@@
    199              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // GPIOA ?@@ ?@@
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    200              RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //  AFIO ?@@ ?@@(USART1??TX, RX ?€???@@?@@ ?@@)
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    201              RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); // USART1 ?@@ ?@@
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF44F 0x4080      MOV      R0,#+16384
   \   00000018   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    202          
    203              // GPIO ?@@
    204              // TX - PA9        
    205              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   0000001C   0xF44F 0x7000      MOV      R0,#+512
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000024   0x8008             STRH     R0,[R1, #+0]
    206              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000002C   0x7088             STRB     R0,[R1, #+2]
    207              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000002E   0x2018             MOVS     R0,#+24
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000034   0x70C8             STRB     R0,[R1, #+3]
    208              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40010800
   \   0000003E   0x.... 0x....      BL       GPIO_Init
    209              // RX - PA10
    210              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000042   0xF44F 0x6080      MOV      R0,#+1024
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000004A   0x8008             STRH     R0,[R1, #+0]
    211              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000052   0x7088             STRB     R0,[R1, #+2]
    212              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   00000054   0x2028             MOVS     R0,#+40
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000005A   0x70C8             STRB     R0,[R1, #+3]
    213              GPIO_Init(GPIOA, &GPIO_InitStructure);    
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40010800
   \   00000064   0x.... 0x....      BL       GPIO_Init
    214              // USART ?@@
    215              USART_Cmd(USART1, ENABLE);
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable20_2  ;; 0x40013800
   \   0000006E   0x.... 0x....      BL       USART_Cmd
    216              USART_InitStructure.USART_BaudRate = 9600; // ?@@ ?@@ ?@@
   \   00000072   0xF44F 0x5016      MOV      R0,#+9600
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    217              USART_InitStructure.USART_WordLength = USART_WordLength_8b;  // ?@@??@@@ ?@@
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000082   0x8088             STRH     R0,[R1, #+4]
    218              USART_InitStructure.USART_StopBits = USART_StopBits_1; // ?@@ @@@ ?@@
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000008A   0x80C8             STRH     R0,[R1, #+6]
    219              USART_InitStructure.USART_Parity = USART_Parity_No;// ?@@???@@
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000092   0x8108             STRH     R0,[R1, #+8]
    220              USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; // ?@@???@@
   \   00000094   0x200C             MOVS     R0,#+12
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000009A   0x8148             STRH     R0,[R1, #+10]
    221              USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // ?@@?@@ ?@@ ?@@ ?@@
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000A2   0x8188             STRH     R0,[R1, #+12]
    222              USART_Init(USART1, &USART_InitStructure); 
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable20_2  ;; 0x40013800
   \   000000AC   0x.... 0x....      BL       USART_Init
    223              USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); // ?@@ ?@@?@@ ?@@
   \   000000B0   0x2201             MOVS     R2,#+1
   \   000000B2   0xF240 0x5125      MOVW     R1,#+1317
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable20_2  ;; 0x40013800
   \   000000BA   0x.... 0x....      BL       USART_ITConfig
    224          }
   \   000000BE   0xBD01             POP      {R0,PC}          ;; return
    225          
    226          // usart2 ?@@
    227          // pd5 - tx
    228          // pd6 - rx

   \                                 In section .text, align 2, keep-with-next
    229          void usart2_config() {
   \                     usart2_config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    230              // ?@@ ?@@
    231              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); // GPIOA ?@@ ?@@
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    232              RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); // AFIO ?@@ ?@@(USART1??TX, RX ?€???@@?@@ ?@@)
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    233              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); // USART2 ?@@ ?@@
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000018   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    234              GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE); // PD5, PD6 ?€??uart2@??@@?@@ ?@@ @@@??
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0x.... 0x....      BL       GPIO_PinRemapConfig
    235              // TX - PD5
    236              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000002A   0x8008             STRH     R0,[R1, #+0]
    237              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000032   0x7088             STRB     R0,[R1, #+2]
    238              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000034   0x2018             MOVS     R0,#+24
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000003A   0x70C8             STRB     R0,[R1, #+3]
    239              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40011400
   \   00000044   0x.... 0x....      BL       GPIO_Init
    240              // RX - PD6
    241              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
   \   00000048   0x2040             MOVS     R0,#+64
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000004E   0x8008             STRH     R0,[R1, #+0]
    242              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000056   0x7088             STRB     R0,[R1, #+2]
    243              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   00000058   0x2028             MOVS     R0,#+40
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000005E   0x70C8             STRB     R0,[R1, #+3]
    244              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40011400
   \   00000068   0x.... 0x....      BL       GPIO_Init
    245              // USART ?@@
    246              USART_Cmd(USART2, ENABLE);
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40004400
   \   00000072   0x.... 0x....      BL       USART_Cmd
    247              USART_InitStructure.USART_BaudRate = 9600; // ?@@ ?@@ ?@@
   \   00000076   0xF44F 0x5016      MOV      R0,#+9600
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    248              USART_InitStructure.USART_WordLength = USART_WordLength_8b; // ?@@??@@@ ?@@
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000086   0x8088             STRH     R0,[R1, #+4]
    249              USART_InitStructure.USART_StopBits = USART_StopBits_1; // ?@@ @@@ ?@@
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000008E   0x80C8             STRH     R0,[R1, #+6]
    250              USART_InitStructure.USART_Parity = USART_Parity_No; // ?@@???@@
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000096   0x8108             STRH     R0,[R1, #+8]
    251              USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; // ?@@???@@
   \   00000098   0x200C             MOVS     R0,#+12
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000009E   0x8148             STRH     R0,[R1, #+10]
    252              USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // ?@@?@@ ?@@ ?@@ ?@@
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000A6   0x8188             STRH     R0,[R1, #+12]
    253              USART_Init(USART2, &USART_InitStructure);
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40004400
   \   000000B0   0x.... 0x....      BL       USART_Init
    254              USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // ?@@ ?@@?@@ ?@@
   \   000000B4   0x2201             MOVS     R2,#+1
   \   000000B6   0xF240 0x5125      MOVW     R1,#+1317
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40004400
   \   000000BE   0x.... 0x....      BL       USART_ITConfig
    255          }
   \   000000C2   0xBD01             POP      {R0,PC}          ;; return
    256          
    257          // adc ?@@???@@??@@@ @€???@@
    258          // PA1 - ?@@ ?@@ ?@@ @??@@?@@
    259          // PC1 - @@@ ?@@ @??@@?@@

   \                                 In section .text, align 2, keep-with-next
    260          void adc_module_config() {
   \                     adc_module_config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    261              // RCC ?@@
    262          
    263              // ADC1 - ?@@ ?@@ ?@@ 
    264              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // GPIOA ?@@ ?@@
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    265              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); // ADC1 ?@@ ?@@
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF44F 0x7000      MOV      R0,#+512
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    266              // ADC2 - @@@ ?@@ 
    267              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); // GPIOC ?@@ ?@@
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x2010             MOVS     R0,#+16
   \   00000018   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    268              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE); // ADC2 ?@@ ?@@
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000022   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    269          
    270          
    271              // GPIO ?@@
    272              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000002C   0x8008             STRH     R0,[R1, #+0]
    273              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000034   0x7088             STRB     R0,[R1, #+2]
    274              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000003C   0x70C8             STRB     R0,[R1, #+3]
    275              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40010800
   \   00000046   0x.... 0x....      BL       GPIO_Init
    276          
    277              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000050   0x8008             STRH     R0,[R1, #+0]
    278              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000058   0x7088             STRB     R0,[R1, #+2]
    279              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000060   0x70C8             STRB     R0,[R1, #+3]
    280              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40011000
   \   0000006A   0x.... 0x....      BL       GPIO_Init
    281          
    282              
    283              
    284              // ADC ?@@
    285              ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; // ?@@ @@@ ?@@
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   00000074   0x6008             STR      R0,[R1, #+0]
    286              ADC_InitStructure.ADC_ScanConvMode = DISABLE; // ?@@ @@@ ?@@
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   0000007C   0x7108             STRB     R0,[R1, #+4]
    287              ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; // ?@@ @€??@@@ ?@@(?@@?@@@?@@@ ?@@?@@ ?@@ ?@@)
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   00000084   0x7148             STRB     R0,[R1, #+5]
    288              ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; // ?@? ?@@@??@@
   \   00000086   0xF45F 0x2060      MOVS     R0,#+917504
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   0000008E   0x6088             STR      R0,[R1, #+8]
    289              ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; // ?@@???@@ ?@@
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   00000096   0x60C8             STR      R0,[R1, #+12]
    290              ADC_InitStructure.ADC_NbrOfChannel = 1; // @@@ ???@@
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   0000009E   0x7408             STRB     R0,[R1, #+16]
    291              ADC_Init(ADC1, &ADC_InitStructure); 
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   000000A8   0x.... 0x....      BL       ADC_Init
    292              ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1, ADC_SampleTime_239Cycles5); // @@@ ?@@
   \   000000AC   0x2307             MOVS     R3,#+7
   \   000000AE   0x2201             MOVS     R2,#+1
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   000000B6   0x.... 0x....      BL       ADC_RegularChannelConfig
    293              
    294              // ADC ?@@
    295              ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; // ?@@ @@@ ?@@
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    296              ADC_InitStructure.ADC_ScanConvMode = DISABLE; // ?@@ @@@ ?@@
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000000C8   0x7108             STRB     R0,[R1, #+4]
    297              ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; // ?@@ @€??@@@ ?@@(?@@?@@@?@@@ ?@@?@@ ?@@ ?@@)
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000000D0   0x7148             STRB     R0,[R1, #+5]
    298              ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; // ?@? ?@@@??@@
   \   000000D2   0xF45F 0x2060      MOVS     R0,#+917504
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000000DA   0x6088             STR      R0,[R1, #+8]
    299              ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; // ?@@???@@ ?@@
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000000E2   0x60C8             STR      R0,[R1, #+12]
    300              ADC_InitStructure.ADC_NbrOfChannel = 1; // @@@ ???@@
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000000EA   0x7408             STRB     R0,[R1, #+16]
    301              ADC_Init(ADC2, &ADC_InitStructure);
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   000000F4   0x.... 0x....      BL       ADC_Init
    302              ADC_RegularChannelConfig(ADC2, ADC_Channel_11, 1, ADC_SampleTime_239Cycles5); // @@@ ?@@
   \   000000F8   0x2307             MOVS     R3,#+7
   \   000000FA   0x2201             MOVS     R2,#+1
   \   000000FC   0x210B             MOVS     R1,#+11
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   00000102   0x.... 0x....      BL       ADC_RegularChannelConfig
    303          
    304          
    305              
    306              ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE); // ADC1 ?@@?@@ ?@@
   \   00000106   0x2201             MOVS     R2,#+1
   \   00000108   0xF44F 0x7108      MOV      R1,#+544
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   00000110   0x.... 0x....      BL       ADC_ITConfig
    307              ADC_Cmd(ADC1, ENABLE); 
   \   00000114   0x2101             MOVS     R1,#+1
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   0000011A   0x.... 0x....      BL       ADC_Cmd
    308              ADC_ResetCalibration(ADC1);
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   00000122   0x.... 0x....      BL       ADC_ResetCalibration
    309          
    310              while(ADC_GetResetCalibrationStatus(ADC1));
   \                     ??adc_module_config_0: (+1)
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   0000012A   0x.... 0x....      BL       ADC_GetResetCalibrationStatus
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD1F9             BNE.N    ??adc_module_config_0
    311              ADC_StartCalibration(ADC1);
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   00000136   0x.... 0x....      BL       ADC_StartCalibration
    312          
    313              while(ADC_GetCalibrationStatus(ADC1)) ;
   \                     ??adc_module_config_1: (+1)
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   0000013E   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD1F9             BNE.N    ??adc_module_config_1
    314              ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \   00000146   0x2101             MOVS     R1,#+1
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   0000014C   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    315          
    316          
    317              // ?@@?@@ ?@@
    318              ADC_ITConfig(ADC2, ADC_IT_EOC, ENABLE); // ADC2 ?@@?@@ ?@@
   \   00000150   0x2201             MOVS     R2,#+1
   \   00000152   0xF44F 0x7108      MOV      R1,#+544
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   0000015A   0x.... 0x....      BL       ADC_ITConfig
    319              ADC_Cmd(ADC2, ENABLE);
   \   0000015E   0x2101             MOVS     R1,#+1
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   00000164   0x.... 0x....      BL       ADC_Cmd
    320              ADC_ResetCalibration(ADC2);
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   0000016C   0x.... 0x....      BL       ADC_ResetCalibration
    321          
    322              while(ADC_GetResetCalibrationStatus(ADC2)) ;
   \                     ??adc_module_config_2: (+1)
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   00000174   0x.... 0x....      BL       ADC_GetResetCalibrationStatus
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD1F9             BNE.N    ??adc_module_config_2
    323              ADC_StartCalibration(ADC2);
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   00000180   0x.... 0x....      BL       ADC_StartCalibration
    324          
    325              while(ADC_GetCalibrationStatus(ADC2)) ;
   \                     ??adc_module_config_3: (+1)
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   00000188   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD1F9             BNE.N    ??adc_module_config_3
    326              ADC_SoftwareStartConvCmd(ADC2, ENABLE);
   \   00000190   0x2101             MOVS     R1,#+1
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   00000196   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    327          }
   \   0000019A   0xBD01             POP      {R0,PC}          ;; return
    328          
    329          
    330          // @??@@ @@@) @€???@@ - TIM3_CH1 - PA6(PWM) 

   \                                 In section .text, align 2, keep-with-next
    331          void servo_config() {
   \                     servo_config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    332              // RCC ?@@
    333              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    334              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    335          
    336              // GPIO ?@@
    337              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
   \   00000012   0x2040             MOVS     R0,#+64
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000018   0x8008             STRH     R0,[R1, #+0]
    338              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000020   0x7088             STRB     R0,[R1, #+2]
    339              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000022   0x2018             MOVS     R0,#+24
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000028   0x70C8             STRB     R0,[R1, #+3]
    340              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40010800
   \   00000032   0x.... 0x....      BL       GPIO_Init
    341          
    342              // TIM ?@@
    343              TIM_TimeBaseStructure.TIM_Period = 20000 - 1; // 20ms @@@ ?@@
   \   00000036   0xF644 0x601F      MOVW     R0,#+19999
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   0000003E   0x8088             STRH     R0,[R1, #+4]
    344              TIM_TimeBaseStructure.TIM_Prescaler = 72 - 1; // 72MHz / 72 = 1MHz
   \   00000040   0x2047             MOVS     R0,#+71
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   00000046   0x8008             STRH     R0,[R1, #+0]
    345              TIM_TimeBaseStructure.TIM_ClockDivision = 0; // ?@@ @@@ ?@@
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   0000004E   0x80C8             STRH     R0,[R1, #+6]
    346              TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; // ??@@@??@@@ ?@@
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   00000056   0x8048             STRH     R0,[R1, #+2]
    347              TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); // TIM3 ?@@
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable20_10
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable20_11  ;; 0x40000400
   \   00000060   0x.... 0x....      BL       TIM_TimeBaseInit
    348          
    349              // PWM ?@@
    350              TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; // PWM @@@ ?@@
   \   00000064   0x2060             MOVS     R0,#+96
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   0000006A   0x8008             STRH     R0,[R1, #+0]
    351              TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; // @@@ ?@@ ?@@
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   00000072   0x8048             STRH     R0,[R1, #+2]
    352              TIM_OCInitStructure.TIM_Pulse = SERVO_RIGHT; // ?@@ @@@ ?@@
   \   00000074   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   0000007C   0x80C8             STRH     R0,[R1, #+6]
    353              TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; // @@@ @@@ ?@@ 
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   00000084   0x8108             STRH     R0,[R1, #+8]
    354              TIM_OC1Init(TIM3, &TIM_OCInitStructure); // TIM3_CH1 ?@@
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable20_11  ;; 0x40000400
   \   0000008E   0x.... 0x....      BL       TIM_OC1Init
    355              TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable); // TIM3_CH1 ?@@
   \   00000092   0x2108             MOVS     R1,#+8
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable20_11  ;; 0x40000400
   \   00000098   0x.... 0x....      BL       TIM_OC1PreloadConfig
    356          
    357              // TIM ?@@
    358              TIM_Cmd(TIM3, ENABLE);
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable20_11  ;; 0x40000400
   \   000000A2   0x.... 0x....      BL       TIM_Cmd
    359          }
   \   000000A6   0xBD01             POP      {R0,PC}          ;; return
    360          
    361          
    362          
    363          // esp32?€ ?@@?@@?@@ ?@@?@@ ?€?@@ ?@@
    364          // PD01 - EXTI 1 ?@@?@@@?@@@@??@@?@@
    365          // PD02 - EXTI 2 ?@@?@@@??@@ @??@@?@@
    366          // PB12 - auto @@@?@? ?@@@€ ?@@?@@
    367          // PB13 - ?@@ ?@@ ?@@ @??@@?@@

   \                                 In section .text, align 2, keep-with-next
    368          void eps32_config() {
   \                     eps32_config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    369              // RCC ?@@
    370              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // GPIOB ?@@ ?@@
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    371              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); // GPIOD ?@@ ?@@
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2020             MOVS     R0,#+32
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    372          
    373              // GPIO ?@@
    374              // ?@@ ?@@(@@@ ?@@, ?@@ ?@@)
    375              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;
   \   00000012   0x2006             MOVS     R0,#+6
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000018   0x8008             STRH     R0,[R1, #+0]
    376              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000020   0x7088             STRB     R0,[R1, #+2]
    377              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000022   0x2048             MOVS     R0,#+72
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000028   0x70C8             STRB     R0,[R1, #+3]
    378              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_Init
    379          
    380              // @@@ ?@@(auto @@@, ?@@ ?@@ ?@@) 
    381              // esp32 ?@@ ?@@@??@@?@@ ?@@ ?@@
    382              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_12;
   \   00000036   0xF44F 0x5040      MOV      R0,#+12288
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000003E   0x8008             STRH     R0,[R1, #+0]
    383              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000046   0x7088             STRB     R0,[R1, #+2]
    384              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000048   0x2010             MOVS     R0,#+16
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000004E   0x70C8             STRB     R0,[R1, #+3]
    385              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable20_13  ;; 0x40010c00
   \   00000058   0x.... 0x....      BL       GPIO_Init
    386          
    387              // EXTI1 ?@@?@@ ?@@ 
    388              GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource1);
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0x.... 0x....      BL       GPIO_EXTILineConfig
    389              EXTI_InitStructure.EXTI_Line = EXTI_Line1;
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    390              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   00000072   0x7108             STRB     R0,[R1, #+4]
    391              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling; // ???@@ @@@ ?@@?@@ @@@(@€?@@ @@@ ?@@?@@ ?@@)
   \   00000074   0x2010             MOVS     R0,#+16
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   0000007A   0x7148             STRB     R0,[R1, #+5]
    392              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   00000082   0x7188             STRB     R0,[R1, #+6]
    393              EXTI_Init(&EXTI_InitStructure);
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   00000088   0x.... 0x....      BL       EXTI_Init
    394          
    395              // EXTI2 ?@@?@@ ?@@
    396              GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource2);
   \   0000008C   0x2102             MOVS     R1,#+2
   \   0000008E   0x2003             MOVS     R0,#+3
   \   00000090   0x.... 0x....      BL       GPIO_EXTILineConfig
    397              EXTI_InitStructure.EXTI_Line = EXTI_Line2;
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    398              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   000000A2   0x7108             STRB     R0,[R1, #+4]
    399              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling; // ???@@ @@@ ?@@?@@ @@@(@€?@@ @@@ ?@@?@@ ?@@)
   \   000000A4   0x2010             MOVS     R0,#+16
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   000000AA   0x7148             STRB     R0,[R1, #+5]
    400              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable20_14
   \   000000B2   0x7188             STRB     R0,[R1, #+6]
    401              EXTI_Init(&EXTI_InitStructure);
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable20_14
   \   000000B8   0x.... 0x....      BL       EXTI_Init
    402          
    403              NVIC_EnableIRQ(EXTI1_IRQn);
   \   000000BC   0x2007             MOVS     R0,#+7
   \   000000BE   0x.... 0x....      BL       __NVIC_EnableIRQ
    404              NVIC_EnableIRQ(EXTI2_IRQn);
   \   000000C2   0x2008             MOVS     R0,#+8
   \   000000C4   0x.... 0x....      BL       __NVIC_EnableIRQ
    405          }
   \   000000C8   0xBD01             POP      {R0,PC}          ;; return
    406          
    407          /*
    408          @??@@ @€???@@
    409          @??@@@??@@ ?€?@@ ?@@ - TIM2 : PA2
    410          @??@@@??@@ GPIO ?@@ - PC4(?@???@@@)
    411          @??@@@??@@ GPIO ?@@ - PA4(?@???@@@)
    412          // set set
    413          // reset set
    414          */

   \                                 In section .text, align 2, keep-with-next
    415          void pump_config() {
   \                     pump_config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    416              // RCC ?@@
    417              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // GPIOA ?@@ ?@@
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    418              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); // GPIOC ?@@ ?@@
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    419              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); // TIM2 ?@@ ?@@
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    420              
    421              // GPIO ?@@
    422              // PC4 - @??@@ ?@@
    423              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
   \   0000001A   0x2010             MOVS     R0,#+16
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000020   0x8008             STRH     R0,[R1, #+0]
    424              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000028   0x7088             STRB     R0,[R1, #+2]
    425              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000002A   0x2010             MOVS     R0,#+16
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000030   0x70C8             STRB     R0,[R1, #+3]
    426              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40011000
   \   0000003A   0x.... 0x....      BL       GPIO_Init
    427          
    428              // PC 7 always on
    429              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
   \   0000003E   0x2010             MOVS     R0,#+16
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000044   0x8008             STRH     R0,[R1, #+0]
    430              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000004C   0x7088             STRB     R0,[R1, #+2]
    431              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000004E   0x2010             MOVS     R0,#+16
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000054   0x70C8             STRB     R0,[R1, #+3]
    432              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40010800
   \   0000005E   0x.... 0x....      BL       GPIO_Init
    433          
    434              // TIM ?@@ - 2 @@@??@@@ @@@ ?@@ ?@@
    435              uint16_t prescaler = 7200;
   \   00000062   0xF44F 0x50E1      MOV      R0,#+7200
    436              TIM_InitStructure.TIM_Period = PUMP_DELAY;
   \   00000066   0xF644 0x6120      MOVW     R1,#+20000
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable20_15
   \   0000006E   0x8091             STRH     R1,[R2, #+4]
    437              TIM_InitStructure.TIM_Prescaler = prescaler;
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable20_15
   \   00000074   0x8008             STRH     R0,[R1, #+0]
    438              TIM_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable20_15
   \   0000007C   0x80C8             STRH     R0,[R1, #+6]
    439              TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable20_15
   \   00000084   0x8048             STRH     R0,[R1, #+2]
    440              TIM_TimeBaseInit(TIM2, &TIM_InitStructure);
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable20_15
   \   0000008A   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000008E   0x.... 0x....      BL       TIM_TimeBaseInit
    441              TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); // ?@@ ???@@?@@@??@@@??@@ ?@@ ?@@
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0x2101             MOVS     R1,#+1
   \   00000096   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000009A   0x.... 0x....      BL       TIM_ITConfig
    442          
    443              // ?@@?@@ ?@@
    444              NVIC_EnableIRQ(TIM2_IRQn);
   \   0000009E   0x201C             MOVS     R0,#+28
   \   000000A0   0x.... 0x....      BL       __NVIC_EnableIRQ
    445              NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
   \   000000A4   0x201C             MOVS     R0,#+28
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
    446              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
   \   000000AC   0x2002             MOVS     R0,#+2
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000B2   0x7048             STRB     R0,[R1, #+1]
    447              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000BA   0x7088             STRB     R0,[R1, #+2]
    448              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000C2   0x70C8             STRB     R0,[R1, #+3]
    449              NVIC_Init(&NVIC_InitStructure);
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   000000C8   0x.... 0x....      BL       NVIC_Init
    450          
    451              // @@@ ?@@ - @??@@ ?@@
    452              GPIO_SetBits(GPIOA, GPIO_Pin_4);
   \   000000CC   0x2110             MOVS     R1,#+16
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40010800
   \   000000D2   0x.... 0x....      BL       GPIO_SetBits
    453              GPIO_SetBits(GPIOC, GPIO_Pin_4);
   \   000000D6   0x2110             MOVS     R1,#+16
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40011000
   \   000000DC   0x.... 0x....      BL       GPIO_SetBits
    454          }
   \   000000E0   0xBD01             POP      {R0,PC}          ;; return
    455          
    456          
    457          // LED ?@@@??@@ GPIO ?@@ - PC5(?@???@@@)
    458          // PC5?€ ?@@??@@@??@@@???@@?@@ ?@@ ?@@

   \                                 In section .text, align 2, keep-with-next
    459          void led_config() {
   \                     led_config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    460              // RCC ?@@
    461              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    462              // GPIO ?@@
    463              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000010   0x8008             STRH     R0,[R1, #+0]
    464              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000018   0x7088             STRB     R0,[R1, #+2]
    465              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000001A   0x2010             MOVS     R0,#+16
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000020   0x70C8             STRB     R0,[R1, #+3]
    466              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable20_6  ;; 0x40011000
   \   0000002A   0x.... 0x....      BL       GPIO_Init
    467          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    468          
    469          /*
    470          -----------------------------------------------------------------------------------
    471          */
    472          
    473          /*
    474          ===================================================================================
    475                                  ?@@?@@ ?@@ ?@@
    476          ===================================================================================
    477          */
    478          
    479          // USART1 ?@@?@@ ?@@
    480          // @@@?@? ?@@ usart1Buffer???€?@@@? @@@@?@@@ ?@@ ??@@@?@? ?@@?@@ ?@@

   \                                 In section .text, align 2, keep-with-next
    481          void USART1_IRQHandler() {
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    482              if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20_2  ;; 0x40013800
   \   0000000A   0x.... 0x....      BL       USART_GetITStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD018             BEQ.N    ??USART1_IRQHandler_0
    483                  char data = USART_ReceiveData(USART1); // ?@@???@@?@@
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable20_2  ;; 0x40013800
   \   00000016   0x.... 0x....      BL       USART_ReceiveData
   \   0000001A   0x0004             MOVS     R4,R0
    484                  readBuffer(&usart1Buffer, data); // @@@???@@???€?
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_16
   \   00000024   0x.... 0x....      BL       readBuffer
    485                  if (data == '\r'|| data == '\n') { // @@@@?@@@ "/r/n" ?@@ ??@@@???@@
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x280D             CMP      R0,#+13
   \   0000002E   0xD002             BEQ.N    ??USART1_IRQHandler_1
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C0A             CMP      R4,#+10
   \   00000034   0xD106             BNE.N    ??USART1_IRQHandler_0
    486                      excuteCommand(USART1_DIR); // @@@???@@ ?@@ 
   \                     ??USART1_IRQHandler_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      BL       excuteCommand
    487                      resetIndex(&usart1Buffer); // @@@ @@@?
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable20_16
   \   00000040   0x.... 0x....      BL       resetIndex
    488                  } 
    489              }
    490              USART_ClearITPendingBit(USART1, USART_IT_RXNE); // ?@@?@@ ?@@@?@@@?
   \                     ??USART1_IRQHandler_0: (+1)
   \   00000044   0xF240 0x5125      MOVW     R1,#+1317
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20_2  ;; 0x40013800
   \   0000004C   0x.... 0x....      BL       USART_ClearITPendingBit
    491          }
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    492          
    493          // USART2 ?@@?@@ ?@@
    494          // esp32@@???@@@?@? ?@@ usart2Buffer???€?@@@? @@@@?@@@ ?@@ ??@@@?@? ?@@?@@ ?@@

   \                                 In section .text, align 2, keep-with-next
    495          void USART2_IRQHandler() {
   \                     USART2_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    496              if (USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) {
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40004400
   \   0000000A   0x.... 0x....      BL       USART_GetITStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD018             BEQ.N    ??USART2_IRQHandler_0
    497                  char data = USART_ReceiveData(USART2); // ?@@???@@?@@
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40004400
   \   00000016   0x.... 0x....      BL       USART_ReceiveData
   \   0000001A   0x0004             MOVS     R4,R0
    498                  readBuffer(&usart2Buffer, data); // @@@???@@???€?
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_17
   \   00000024   0x.... 0x....      BL       readBuffer
    499                  if (data == '\r' || data == '\n') {
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x280D             CMP      R0,#+13
   \   0000002E   0xD002             BEQ.N    ??USART2_IRQHandler_1
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C0A             CMP      R4,#+10
   \   00000034   0xD106             BNE.N    ??USART2_IRQHandler_0
    500                      excuteCommand(USART2_DIR); // @@@???@@ ?@@
   \                     ??USART2_IRQHandler_1: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       excuteCommand
    501                      resetIndex(&usart2Buffer); // @@@ @@@?
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable20_17
   \   00000040   0x.... 0x....      BL       resetIndex
    502                  }
    503              }
    504              USART_ClearITPendingBit(USART2, USART_IT_RXNE); // ?@@?@@ ?@@@?@@@?
   \                     ??USART2_IRQHandler_0: (+1)
   \   00000044   0xF240 0x5125      MOVW     R1,#+1317
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x40004400
   \   0000004C   0x.... 0x....      BL       USART_ClearITPendingBit
    505          }
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    506          
    507          /* ADC ?@@?@@ ?@@ - ?@@ ?@@ ?@@ @??@@?@@ */
    508          // PB13 ?@@ @@@?@@ esp32@??@@ ?@@?@@ ?@@

   \                                 In section .text, align 2, keep-with-next
    509          void ADC1_2_IRQHandler() {
   \                     ADC1_2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    510          
    511              // ?@@ ?@@ ?@@(ADC1, PA1)?@@ @@@ ?@@?@@ ?@@ ?@@?@@ @@@
    512              if (ADC_GetITStatus(ADC1, ADC_IT_EOC) != RESET) { 
   \   00000002   0xF44F 0x7108      MOV      R1,#+544
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   0000000A   0x.... 0x....      BL       ADC_GetITStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD03E             BEQ.N    ??ADC1_2_IRQHandler_0
    513                  uint16_t adcValue = ADC_GetConversionValue(ADC1);
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   00000016   0x.... 0x....      BL       ADC_GetConversionValue
    514                  deviceState.soilMoisture = adcValue; // ?@@ ?@@ @??€?
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable20_18
   \   0000001E   0x8008             STRH     R0,[R1, #+0]
    515                  sensorState.isWet = (adcValue > WET_LIMIT) ? true : false; // ?@@ ?@@ ?@@ ?€?
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0xF240 0x11F5      MOVW     R1,#+501
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xDB01             BLT.N    ??ADC1_2_IRQHandler_1
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE000             B.N      ??ADC1_2_IRQHandler_2
   \                     ??ADC1_2_IRQHandler_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??ADC1_2_IRQHandler_2: (+1)
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable20_19
   \   00000034   0x7088             STRB     R0,[R1, #+2]
    516                  
    517                  // ?@@?@@@€ @@@?@@ ?@@@@@?????@@@??@@.
    518                  // ?@@?@@ ?@@@?esp32@??@@?@@ ?@@ ?€??@@@?@@.
    519                  if (sensorState.isWet) {
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable20_19
   \   0000003A   0x7880             LDRB     R0,[R0, #+2]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD00E             BEQ.N    ??ADC1_2_IRQHandler_3
    520                      if (deviceState.mode) { 
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   00000044   0x7900             LDRB     R0,[R0, #+4]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD002             BEQ.N    ??ADC1_2_IRQHandler_4
    521                          controlPump(false);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       controlPump
    522                      }
    523                      GPIO_SetBits(GPIOB, GPIO_Pin_13);
   \                     ??ADC1_2_IRQHandler_4: (+1)
   \   00000050   0xF44F 0x5100      MOV      R1,#+8192
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable20_13  ;; 0x40010c00
   \   00000058   0x.... 0x....      BL       GPIO_SetBits
   \   0000005C   0xE012             B.N      ??ADC1_2_IRQHandler_5
    524          
    525                  // ?@@?@@@€ @@@?@? ?@@ ?@@@@@????@@@ @€??
    526                  // ?@@?@@ ?@@@?esp32@??@@?@@ ?@@ ?€??@@@?@@.
    527                  } else if (!sensorState.isWet) {
   \                     ??ADC1_2_IRQHandler_3: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable20_19
   \   00000062   0x7880             LDRB     R0,[R0, #+2]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD10D             BNE.N    ??ADC1_2_IRQHandler_5
    528                      if (deviceState.mode) {
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   0000006C   0x7900             LDRB     R0,[R0, #+4]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD002             BEQ.N    ??ADC1_2_IRQHandler_6
    529                          controlPump(true);
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x.... 0x....      BL       controlPump
    530                      }
    531                      GPIO_ResetBits(GPIOB, GPIO_Pin_13);
   \                     ??ADC1_2_IRQHandler_6: (+1)
   \   00000078   0xF44F 0x5100      MOV      R1,#+8192
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable20_13  ;; 0x40010c00
   \   00000080   0x.... 0x....      BL       GPIO_ResetBits
    532                  }
    533                  ADC_ClearITPendingBit(ADC1, ADC_IT_EOC);
   \                     ??ADC1_2_IRQHandler_5: (+1)
   \   00000084   0xF44F 0x7108      MOV      R1,#+544
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable20_8  ;; 0x40012400
   \   0000008C   0x.... 0x....      BL       ADC_ClearITPendingBit
    534              }
    535          
    536              // @@@ ?@@(ADC2, PC1)?@@ @@@ ?@@?@@ ?@@ ?@@?@@ @@@
    537              if (ADC_GetITStatus(ADC2, ADC_IT_EOC) != RESET) {
   \                     ??ADC1_2_IRQHandler_0: (+1)
   \   00000090   0xF44F 0x7108      MOV      R1,#+544
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   00000098   0x.... 0x....      BL       ADC_GetITStatus
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD037             BEQ.N    ??ADC1_2_IRQHandler_7
    538                  uint16_t adcValue = ADC_GetConversionValue(ADC2); // @@@ ?@@ @??@@?@@
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   000000A4   0x.... 0x....      BL       ADC_GetConversionValue
    539                  deviceState.light = adcValue; // @@@ @??€?
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable20_18
   \   000000AC   0x8048             STRH     R0,[R1, #+2]
    540                  sensorState.isBright = (adcValue > BRIGHT_LIMIT) ? true : false; // @@@ ?@@ ?@@ ?€?
   \   000000AE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B0   0xF240 0x41E3      MOVW     R1,#+1251
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xDB01             BLT.N    ??ADC1_2_IRQHandler_8
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xE000             B.N      ??ADC1_2_IRQHandler_9
   \                     ??ADC1_2_IRQHandler_8: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \                     ??ADC1_2_IRQHandler_9: (+1)
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable20_19
   \   000000C2   0x70C8             STRB     R0,[R1, #+3]
    541                  // @@@@€ ?@@??@@@ led@??@@?@@.
    542                  if (deviceState.mode) {
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   000000C8   0x7900             LDRB     R0,[R0, #+4]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD01A             BEQ.N    ??ADC1_2_IRQHandler_10
    543                      // led@€ @@@?@@ @@? ?@@????led@??@@.
    544                      if (sensorState.isBright && deviceState.led) {
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable20_19
   \   000000D2   0x78C0             LDRB     R0,[R0, #+3]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD008             BEQ.N    ??ADC1_2_IRQHandler_11
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   000000DC   0x7940             LDRB     R0,[R0, #+5]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD003             BEQ.N    ??ADC1_2_IRQHandler_11
    545                          controlLED(false);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x.... 0x....      BL       controlLED
   \   000000E8   0xE00C             B.N      ??ADC1_2_IRQHandler_10
    546                      // led@€ @@@?@@ ?@@???@@????led@?@@@.
    547                      } else if (!sensorState.isBright && !deviceState.led){
   \                     ??ADC1_2_IRQHandler_11: (+1)
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable20_19
   \   000000EE   0x78C0             LDRB     R0,[R0, #+3]
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD107             BNE.N    ??ADC1_2_IRQHandler_10
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   000000F8   0x7940             LDRB     R0,[R0, #+5]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD102             BNE.N    ??ADC1_2_IRQHandler_10
    548                          controlLED(true);
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x.... 0x....      BL       controlLED
    549                      }
    550                  }
    551                  ADC_ClearITPendingBit(ADC2, ADC_IT_EOC);
   \                     ??ADC1_2_IRQHandler_10: (+1)
   \   00000104   0xF44F 0x7108      MOV      R1,#+544
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable20_9  ;; 0x40012800
   \   0000010C   0x.... 0x....      BL       ADC_ClearITPendingBit
    552              }
    553          }
   \                     ??ADC1_2_IRQHandler_7: (+1)
   \   00000110   0xBD01             POP      {R0,PC}          ;; return
    554          
    555          /* TIM2 ?@@?@@ ?@@ - @??@@ ?@@ */
    556          // water ?@@ ?@@ ??2@????@@ @@@@??@@?@@ ?@@?@@ @@@

   \                                 In section .text, align 2, keep-with-next
    557          void TIM2_IRQHandler() {
   \                     TIM2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    558              if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) {
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000008   0x.... 0x....      BL       TIM_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00C             BEQ.N    ??TIM2_IRQHandler_0
    559                  controlPump(false); // ?@@ ?@@
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       controlPump
    560                  TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000001C   0x.... 0x....      BL       TIM_ClearITPendingBit
    561                  TIM_Cmd(TIM2, DISABLE);
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000026   0x.... 0x....      BL       TIM_Cmd
    562              }
    563          }
   \                     ??TIM2_IRQHandler_0: (+1)
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    564          
    565          /* EXTI1 ?@@?@@ ?@@ - @@@ ?@@ ?@@ ?@@?@@ */
    566          // rising, falling edge ?@@?@@@??€ ?@@ @€?@? ?@@?@@.
    567          // esp32?@@ @€???@@??@@@ ?@@ ?@@@??€?@@@?@@@???@@ @??@@ @@@)@??@@?@@.

   \                                 In section .text, align 2, keep-with-next
    568          void EXTI1_IRQHandler() {
   \                     EXTI1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    569              if (EXTI_GetITStatus(EXTI_Line1) != RESET) {
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD031             BEQ.N    ??EXTI1_IRQHandler_0
    570                  sensorState.isClose = GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_1); // @@@ ?@@ ?@@ ?@@?@@
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40011400
   \   00000012   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??EXTI1_IRQHandler_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE000             B.N      ??EXTI1_IRQHandler_2
   \                     ??EXTI1_IRQHandler_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??EXTI1_IRQHandler_2: (+1)
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20_19
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    571                  // "?@@"@@@????@@@ ?@@ ?@@???@@ @@@ ?@@?@@.
    572                  if (deviceState.mode) {
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   0000002A   0x7900             LDRB     R0,[R0, #+4]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD01C             BEQ.N    ??EXTI1_IRQHandler_3
    573                      // @@@ ?@@?@@ @@@ ?@@@€ @€@@@ ?@@????@@@ ?@@??
    574                      if (sensorState.isClose && deviceState.door){
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable20_19
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD009             BEQ.N    ??EXTI1_IRQHandler_4
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   0000003E   0x7980             LDRB     R0,[R0, #+6]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD004             BEQ.N    ??EXTI1_IRQHandler_4
    575                        controlServo(SERVO_LEFT);
   \   00000044   0xF44F 0x70FA      MOV      R0,#+500
   \   00000048   0x.... 0x....      BL       controlServo
   \   0000004C   0xE00D             B.N      ??EXTI1_IRQHandler_3
    576                      // @@@ ?@??@@ @@@ ?@@@€ @€@??@@@??@@????@@@ ?@@??
    577                      } else if (!sensorState.isClose && !deviceState.door){
   \                     ??EXTI1_IRQHandler_4: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20_19
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD108             BNE.N    ??EXTI1_IRQHandler_3
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   0000005C   0x7980             LDRB     R0,[R0, #+6]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD103             BNE.N    ??EXTI1_IRQHandler_3
    578                        controlServo(SERVO_RIGHT);
   \   00000062   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000066   0x.... 0x....      BL       controlServo
    579                      }
    580                  }
    581                  EXTI_ClearITPendingBit(EXTI_Line1);
   \                     ??EXTI1_IRQHandler_3: (+1)
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x.... 0x....      BL       EXTI_ClearITPendingBit
    582              }
    583          }
   \                     ??EXTI1_IRQHandler_0: (+1)
   \   00000070   0xBD01             POP      {R0,PC}          ;; return
    584          
    585          /* EXTI2 ?@@?@@ ?@@ - ?@@@€ @@@?@? ?@@?@@ */
    586          // rising, falling edge ?@@?@@@??€ ?@@ @€?@? ?@@?@@.
    587          // esp32?@@ @€???@@???@@ ?@@ ?@@@??€?@@??

   \                                 In section .text, align 2, keep-with-next
    588          void EXTI2_IRQHandler() {
   \                     EXTI2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    589              if (EXTI_GetITStatus(EXTI_Line2) != RESET) {
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00F             BEQ.N    ??EXTI2_IRQHandler_0
    590                  sensorState.isEnough = (GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_2)); // ?@@ ?@@ ?@@ ?@@?@@
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x40011400
   \   00000012   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??EXTI2_IRQHandler_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE000             B.N      ??EXTI2_IRQHandler_2
   \                     ??EXTI2_IRQHandler_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??EXTI2_IRQHandler_2: (+1)
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20_19
   \   00000024   0x7048             STRB     R0,[R1, #+1]
    591                  EXTI_ClearITPendingBit(EXTI_Line2);
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x.... 0x....      BL       EXTI_ClearITPendingBit
    592              }
    593          }
   \                     ??EXTI2_IRQHandler_0: (+1)
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
    594          /*
    595          -----------------------------------------------------------------------------------
    596          */
    597          
    598          
    599          /*
    600          ===================================================================================
    601                                  ?@@???@@ ?@@ ?@@
    602          ===================================================================================
    603          */
    604          
    605          /* USART ?@@ @€???@@ - ?@@??@?@@@???€??& ?@@?@@??@@? */
    606          // @@@???@@?@? ?€?@@@? @@@???@@@??@@@€@€ ?@@@??@@?@@
    607          // @@@@?@@@('\r')@?@@@ ?@@@??@@?@@.

   \                                 In section .text, align 2, keep-with-next
    608          void readBuffer(Buffer* buffer, char data) {
    609              if (buffer->index < BUFFER_SIZE - 1) {
   \                     readBuffer: (+1)
   \   00000000   0xF8D0 0x20C8      LDR      R2,[R0, #+200]
   \   00000004   0x2AC7             CMP      R2,#+199
   \   00000006   0xD213             BCS.N    ??readBuffer_0
    610                  if (data == '\r')
   \   00000008   0x000A             MOVS     R2,R1
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x2A0D             CMP      R2,#+13
   \   0000000E   0xD104             BNE.N    ??readBuffer_1
    611                      buffer->mem[buffer->index] = '\0';
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xF8D0 0x20C8      LDR      R2,[R0, #+200]
   \   00000016   0x5481             STRB     R1,[R0, R2]
   \   00000018   0xE00D             B.N      ??readBuffer_2
    612                  else if (data == '\n') return;
   \                     ??readBuffer_1: (+1)
   \   0000001A   0x000A             MOVS     R2,R1
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x2A0A             CMP      R2,#+10
   \   00000020   0xD009             BEQ.N    ??readBuffer_3
    613                  else 
    614                      buffer->mem[buffer->index++] = data;
   \                     ??readBuffer_4: (+1)
   \   00000022   0xF8D0 0x20C8      LDR      R2,[R0, #+200]
   \   00000026   0x1C53             ADDS     R3,R2,#+1
   \   00000028   0xF8C0 0x30C8      STR      R3,[R0, #+200]
   \   0000002C   0x5481             STRB     R1,[R0, R2]
   \   0000002E   0xE002             B.N      ??readBuffer_2
    615              } else {
    616                  buffer->mem[BUFFER_SIZE - 1] = '\0';
   \                     ??readBuffer_0: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF880 0x10C7      STRB     R1,[R0, #+199]
    617              }
    618          }
   \                     ??readBuffer_2: (+1)
   \                     ??readBuffer_3: (+1)
   \   00000036   0x4770             BX       LR               ;; return
    619          
    620          /*USART ?@@ @€???@@ -  @@@ ?@@??@@@??*/
    621          // @@@???@@?@? @@@?@@??

   \                                 In section .text, align 2, keep-with-next
    622          void resetIndex(Buffer* buffer) {
    623              buffer->index = 0;
   \                     resetIndex: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF8C0 0x10C8      STR      R1,[R0, #+200]
    624          }
   \   00000006   0x4770             BX       LR               ;; return
    625          
    626          /* USART ?@@ @€???@@ - @@@???@@ ?@@ & ?@@ ?@@*/
    627          // @@@?@? @@@?@@, ?@@ @@@?@@ ?@@ ?@@???@@?@@. 
    628          // @@@@€?@@ @€???@@ USART?@@ @@@?@? ?@@?@@@€ @@@?@@.

   \                                 In section .text, align 2, keep-with-next
    629          void excuteCommand(USART_DIR which_usart) {
   \                     excuteCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    630              // ?@@??@@@?@? ?@@?@@@€??@@@??@@@@??@@?@@.
    631              char* command = (which_usart == USART1_DIR) ? usart1Buffer.mem : usart2Buffer.mem;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD102             BNE.N    ??excuteCommand_0
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable20_16
   \   0000000C   0xE001             B.N      ??excuteCommand_1
   \                     ??excuteCommand_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable20_17
    632              // @@@??@@@
    633              // "set mode 1" : auto @@@@?@€@
    634              if (strcmp(command, SET_MODE_AUTO) == 0) {
   \                     ??excuteCommand_1: (+1)
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable20_20
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       strcmp
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD111             BNE.N    ??excuteCommand_2
    635                  if (deviceState.mode) return;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   00000024   0x7900             LDRB     R0,[R0, #+4]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD15D             BNE.N    ??excuteCommand_3
    636                  initialModules(); // @@@ @@@ @@@?
   \                     ??excuteCommand_4: (+1)
   \   0000002A   0x.... 0x....      BL       initialModules
    637                  GPIO_SetBits(GPIOB, GPIO_Pin_12); // esp32?@@ auto @@@@?@€@@@?@@???@@
   \   0000002E   0xF44F 0x5180      MOV      R1,#+4096
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable20_13  ;; 0x40010c00
   \   00000036   0x.... 0x....      BL       GPIO_SetBits
    638                  deviceState.mode = true; // @@@@@@ mode ?@@ ?€?
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable20_18
   \   00000040   0x7108             STRB     R0,[R1, #+4]
    639                  return;
   \   00000042   0xE050             B.N      ??excuteCommand_3
    640              // "set mode 0" : manual @@@@?@€@
    641              } else if (strcmp(command, SET_MODE_MANUAL) == 0) {
   \                     ??excuteCommand_2: (+1)
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable20_21
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       strcmp
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD111             BNE.N    ??excuteCommand_5
    642                  if (!deviceState.mode) return;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   00000056   0x7900             LDRB     R0,[R0, #+4]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD044             BEQ.N    ??excuteCommand_3
    643                  initialModules(); // @@@ @@@ @@@?
   \                     ??excuteCommand_6: (+1)
   \   0000005C   0x.... 0x....      BL       initialModules
    644                  GPIO_ResetBits(GPIOB, GPIO_Pin_12); // esp32?@@ manual @@@@?@€@@@?@@???@@
   \   00000060   0xF44F 0x5180      MOV      R1,#+4096
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable20_13  ;; 0x40010c00
   \   00000068   0x.... 0x....      BL       GPIO_ResetBits
    645                  deviceState.mode = false; // @@@@@@ mode ?@@ ?€?
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable20_18
   \   00000072   0x7108             STRB     R0,[R1, #+4]
    646                  return;
   \   00000074   0xE037             B.N      ??excuteCommand_3
    647              } 
    648          
    649              // @@@ ?@@ @€??@@@???@? ?@@ @@@???@@ ?@@?@@.
    650              if (!deviceState.mode) {
   \                     ??excuteCommand_5: (+1)
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable20_18
   \   0000007A   0x7900             LDRB     R0,[R0, #+4]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD132             BNE.N    ??excuteCommand_7
    651                  // "set led 1" : led @@@
    652                  if (strcmp(command, SET_LED_ON) == 0) {
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable20_22
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       strcmp
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD103             BNE.N    ??excuteCommand_8
    653                      controlLED(true); // led @@@
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x.... 0x....      BL       controlLED
   \   00000094   0xE027             B.N      ??excuteCommand_7
    654                  // "set led 0" : led ?@@
    655                  } else if (strcmp(command, SET_LED_OFF) == 0) {
   \                     ??excuteCommand_8: (+1)
   \   00000096   0x....             LDR.N    R1,??DataTable20_23
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       strcmp
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD103             BNE.N    ??excuteCommand_9
    656                      controlLED(false); // led ?@@
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x.... 0x....      BL       controlLED
   \   000000A8   0xE01D             B.N      ??excuteCommand_7
    657                  // "set door 1" : @??@@
    658                  } else if (strcmp(command, SET_DOOR_OPEN) == 0) {
   \                     ??excuteCommand_9: (+1)
   \   000000AA   0x....             LDR.N    R1,??DataTable20_24
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       strcmp
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD104             BNE.N    ??excuteCommand_10
    659                      controlServo(SERVO_LEFT); // @??@@
   \   000000B6   0xF44F 0x70FA      MOV      R0,#+500
   \   000000BA   0x.... 0x....      BL       controlServo
   \   000000BE   0xE012             B.N      ??excuteCommand_7
    660                  // "set door 0" : @??@@
    661                  } else if (strcmp(command, SET_DOOR_CLOSE) == 0) {
   \                     ??excuteCommand_10: (+1)
   \   000000C0   0x....             LDR.N    R1,??DataTable20_25
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       strcmp
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD104             BNE.N    ??excuteCommand_11
    662                      controlServo(SERVO_RIGHT); // @??@@
   \   000000CC   0xF44F 0x60FA      MOV      R0,#+2000
   \   000000D0   0x.... 0x....      BL       controlServo
   \   000000D4   0xE007             B.N      ??excuteCommand_7
    663                  // "water" : @?@@@
    664                  } else if (strcmp(command, WATERING) == 0) {
   \                     ??excuteCommand_11: (+1)
   \   000000D6   0x....             LDR.N    R1,??DataTable20_26
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       strcmp
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD101             BNE.N    ??excuteCommand_7
    665                      water(); // @?@@@
   \   000000E2   0x.... 0x....      BL       water
    666                  }
    667              }
    668          }
   \                     ??excuteCommand_7: (+1)
   \                     ??excuteCommand_3: (+1)
   \   000000E6   0xBD10             POP      {R4,PC}          ;; return
    669          
    670          /* @??@@ @@@)@??@@?@@ ?@@ */

   \                                 In section .text, align 2, keep-with-next
    671          void controlServo(uint16_t pulse) {
   \                     controlServo: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    672              // @€@@@ @@@ ?@@@?@@@@@@ ?€?
    673              if (pulse == SERVO_LEFT) deviceState.door = false;
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0xF5B1 0x7FFA      CMP      R1,#+500
   \   0000000A   0xD103             BNE.N    ??controlServo_0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x....             LDR.N    R2,??DataTable20_18
   \   00000010   0x7191             STRB     R1,[R2, #+6]
   \   00000012   0xE002             B.N      ??controlServo_1
    674              else deviceState.door = true;
   \                     ??controlServo_0: (+1)
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x....             LDR.N    R2,??DataTable20_18
   \   00000018   0x7191             STRB     R1,[R2, #+6]
    675              
    676              
    677              TIM_OCInitStructure.TIM_Pulse = pulse; // ?@@ ??@ @@@??@??@@
   \                     ??controlServo_1: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable20_12
   \   0000001C   0x80C8             STRH     R0,[R1, #+6]
    678              TIM_OC1Init(TIM3, &TIM_OCInitStructure); // @€@@@ ?@@ ?@@
   \   0000001E   0x....             LDR.N    R1,??DataTable20_12
   \   00000020   0x....             LDR.N    R0,??DataTable20_11  ;; 0x40000400
   \   00000022   0x.... 0x....      BL       TIM_OC1Init
    679              TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);
   \   00000026   0x2108             MOVS     R1,#+8
   \   00000028   0x....             LDR.N    R0,??DataTable20_11  ;; 0x40000400
   \   0000002A   0x.... 0x....      BL       TIM_OC1PreloadConfig
    680          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    681          
    682          /* LED ?@@ ?@@(@@@??@@@ ?@@) */

   \                                 In section .text, align 2, keep-with-next
    683          void controlLED(bool on) {
   \                     controlLED: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    684            if (on) {
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD007             BEQ.N    ??controlLED_0
    685              GPIO_SetBits(GPIOC, GPIO_Pin_5); // led @@@
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0x....             LDR.N    R0,??DataTable20_6  ;; 0x40011000
   \   0000000C   0x.... 0x....      BL       GPIO_SetBits
    686              deviceState.led = true; // led ?@@ @@@@@@ ?€?
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable20_18
   \   00000014   0x7148             STRB     R0,[R1, #+5]
   \   00000016   0xE006             B.N      ??controlLED_1
    687            }
    688            else {
    689              GPIO_ResetBits(GPIOC, GPIO_Pin_5); // led ?@@
   \                     ??controlLED_0: (+1)
   \   00000018   0x2120             MOVS     R1,#+32
   \   0000001A   0x....             LDR.N    R0,??DataTable20_6  ;; 0x40011000
   \   0000001C   0x.... 0x....      BL       GPIO_ResetBits
    690              deviceState.led = false; // led ?@@ @@@@@@ ?€?
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable20_18
   \   00000024   0x7148             STRB     R0,[R1, #+5]
    691            }
    692          }
   \                     ??controlLED_1: (+1)
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    693          
    694          /* @??@@ ?@@?@@ */

   \                                 In section .text, align 2, keep-with-next
    695          void water() {
   \                     water: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    696              if (pumpState == PUMP_ON) return; // ?@? @@@ @@@ ?@@ ?@@?????@@ @@@
   \   00000002   0x....             LDR.N    R0,??DataTable20_27
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD00A             BEQ.N    ??water_0
    697              controlPump(true); // @??@@ @@@
   \                     ??water_1: (+1)
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       controlPump
    698              pumpState = PUMP_ON; // @??@@ ?@@ ?€?
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable20_27
   \   00000014   0x7008             STRB     R0,[R1, #+0]
    699              // 2@???@??@@ ?@@
    700              TIM_Cmd(TIM2, ENABLE); // ?€?@@???@@?@@@€ @??@@@??@@ ?@@ ?@@
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000001C   0x.... 0x....      BL       TIM_Cmd
    701          }
   \                     ??water_0: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    702          
    703          // ?@@ @@@?@@ @@@ @@@ ?@@ ?@@
    704          // ?€?@@@??@@?@? ?@@ @@@?@@@??@@ ?@@

   \                                 In section .text, align 2, keep-with-next
    705          void controlPump(bool on) { 
   \                     controlPump: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    706              if (on) {
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD00B             BEQ.N    ??controlPump_0
    707                  // @??@@ @@@
    708                  GPIO_SetBits(GPIOA, GPIO_Pin_4); 
   \   00000008   0x2110             MOVS     R1,#+16
   \   0000000A   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40010800
   \   0000000C   0x.... 0x....      BL       GPIO_SetBits
    709                  GPIO_ResetBits(GPIOC, GPIO_Pin_4);
   \   00000010   0x2110             MOVS     R1,#+16
   \   00000012   0x....             LDR.N    R0,??DataTable20_6  ;; 0x40011000
   \   00000014   0x.... 0x....      BL       GPIO_ResetBits
    710                  pumpState = PUMP_ON; // @??@@ ?@@@?@@@@@@ ?€?
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable20_27
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
   \   0000001E   0xE00A             B.N      ??controlPump_1
    711              } else {
    712                  // @??@@ ?@@
    713                  GPIO_SetBits(GPIOA, GPIO_Pin_4);
   \                     ??controlPump_0: (+1)
   \   00000020   0x2110             MOVS     R1,#+16
   \   00000022   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40010800
   \   00000024   0x.... 0x....      BL       GPIO_SetBits
    714                  GPIO_SetBits(GPIOC, GPIO_Pin_4);
   \   00000028   0x2110             MOVS     R1,#+16
   \   0000002A   0x....             LDR.N    R0,??DataTable20_6  ;; 0x40011000
   \   0000002C   0x.... 0x....      BL       GPIO_SetBits
    715                  pumpState = PUMP_OFF; // @??@@ ?@@@?@@@@@@ ?€?
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x....             LDR.N    R1,??DataTable20_27
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    716              }
    717          }
   \                     ??controlPump_1: (+1)
   \   00000036   0xBD01             POP      {R0,PC}          ;; return
    718          
    719          // ?@@???@@(@@@@??@@)

   \                                 In section .text, align 2, keep-with-next
    720          void myDelay(uint32_t count) {
    721              for (int i=0; i<count; ++i);
   \                     myDelay: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE000             B.N      ??myDelay_0
   \                     ??myDelay_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??myDelay_0: (+1)
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD3FC             BCC.N    ??myDelay_1
    722          }
   \   0000000A   0x4770             BX       LR               ;; return
    723          
    724          // usart2??json ?@@???@@?@? ?@@?@@ ?@@ ?@@

   \                                 In section .text, align 2, keep-with-next
    725          void sendJsonToUART() {
   \                     sendJsonToUART: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    726              sprintf(jsonBuffer.mem, 
    727                  /*
    728                      json @@@ : {"mode":0, "led":0, "door":0, "soil":0, "light":0, "level":0}
    729                  */
    730          
    731                  "{\"mode\":%d, \"led\":%d, \"door\":%d, \"soil\":%d, \"light\":%d, \"level\":%d}\r\n",
    732                   deviceState.mode, deviceState.led, deviceState.door, deviceState.soilMoisture, deviceState.light, sensorState.isEnough);
   \   00000002   0x....             LDR.N    R0,??DataTable20_19
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0x9003             STR      R0,[SP, #+12]
   \   00000008   0x....             LDR.N    R0,??DataTable20_18
   \   0000000A   0x8840             LDRH     R0,[R0, #+2]
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0x....             LDR.N    R0,??DataTable20_18
   \   00000010   0x8800             LDRH     R0,[R0, #+0]
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0x....             LDR.N    R0,??DataTable20_18
   \   00000016   0x7980             LDRB     R0,[R0, #+6]
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x....             LDR.N    R0,??DataTable20_18
   \   0000001C   0x7943             LDRB     R3,[R0, #+5]
   \   0000001E   0x....             LDR.N    R0,??DataTable20_18
   \   00000020   0x7902             LDRB     R2,[R0, #+4]
   \   00000022   0x....             LDR.N    R1,??DataTable20_28
   \   00000024   0x....             LDR.N    R0,??DataTable20_29
   \   00000026   0x.... 0x....      BL       sprintf
    733              for (int i=0; jsonBuffer.mem[i] != '\0'; ++i) {
   \   0000002A   0x2400             MOVS     R4,#+0
   \   0000002C   0xE00A             B.N      ??sendJsonToUART_0
    734                  USART_SendData(USART2,jsonBuffer.mem[i]);
   \                     ??sendJsonToUART_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable20_29
   \   00000030   0x5D01             LDRB     R1,[R0, R4]
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0x....             LDR.N    R0,??DataTable20_5  ;; 0x40004400
   \   00000036   0x.... 0x....      BL       USART_SendData
    735                  myDelay(USART2_DELAY);
   \   0000003A   0xF644 0x6020      MOVW     R0,#+20000
   \   0000003E   0x.... 0x....      BL       myDelay
    736              }
   \   00000042   0x1C64             ADDS     R4,R4,#+1
   \                     ??sendJsonToUART_0: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable20_29
   \   00000046   0x5D00             LDRB     R0,[R0, R4]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD1F0             BNE.N    ??sendJsonToUART_1
    737          }
   \   0000004C   0xBD1F             POP      {R0-R4,PC}       ;; return
    738          
    739          // @@@ ?@@@?@@@?@@???@@

   \                                 In section .text, align 2, keep-with-next
    740          void initialModules() {
   \                     initialModules: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    741              controlServo(SERVO_RIGHT); // @??@@
   \   00000002   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000006   0x.... 0x....      BL       controlServo
    742              controlLED(false); // led ?@@
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       controlLED
    743              controlPump(false); // @??@@ ?@@
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       controlPump
    744          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    745          
    746          /*
    747          -----------------------------------------------------------------------------------
    748          */
    749          
    750          /*
    751          ===================================================================================
    752                                  @@@ ?@@
    753          ===================================================================================
    754          */
    755          
    756          
    757           

   \                                 In section .text, align 2, keep-with-next
    758          int main() {
   \                     main: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB0E5             SUB      SP,SP,#+404
    759              char pBuffer[400];
    760          
    761              adc_module_config(); // ?@@@@@ @@@ ?@@(?@@ ?@@, @@@)
   \   00000004   0x.... 0x....      BL       adc_module_config
    762              usart1_config(); // usart1 ?@@
   \   00000008   0x.... 0x....      BL       usart1_config
    763              usart2_config();
   \   0000000C   0x.... 0x....      BL       usart2_config
    764              eps32_config(); // esp32?€ ?@@?@@?@@ ?@@?@@ ?€??@@@?
   \   00000010   0x.... 0x....      BL       eps32_config
    765              servo_config(); // @??@@ @@@) @€???@@
   \   00000014   0x.... 0x....      BL       servo_config
    766              pump_config(); // @??@@ @€???@@
   \   00000018   0x.... 0x....      BL       pump_config
    767              led_config(); // led(@@@??@@@) @€???@@
   \   0000001C   0x.... 0x....      BL       led_config
    768              NVIC_Config(); // ?@@?@@ ?@@
   \   00000020   0x.... 0x....      BL       NVIC_Config
    769              LCD_Init(); // LCD @@@?
   \   00000024   0x.... 0x....      BL       LCD_Init
    770              LCD_Clear(WHITE);  // ?@@???@@?@@ @@@?
   \   00000028   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000002C   0x.... 0x....      BL       LCD_Clear
    771              initialModules(); // @@@ @@@?
   \   00000030   0x.... 0x....      BL       initialModules
   \   00000034   0xE06B             B.N      ??main_0
    772              
    773              while(1) {
    774                  // ?@@ @@@
    775                  // @@@??@@@ @€@@@ ???@@ ?@@@€ ?@@@@@????@ ??- esp32)
    776                  if (!sensorState.isEnough) {
    777                      LCD_ShowString(10, 10, "Need to supply water", BLACK, WHITE);
    778                  // ?@@ ?@@@€ @€@@@ ???@@ ?@@ ?@@@€ ?@@@@@????@ ??
    779                  } else if (!sensorState.isWet) {
    780                      LCD_ShowString(10, 10, "give water to plant       ", BLACK, WHITE);
    781                  // @@@ ?@@@€ ?@@???
    782                  } else {
    783                      LCD_ShowString(10, 10, "Good condition            ", BLACK, WHITE);
    784                  }
    785          
    786                  // @@@ @@@ - ?@@@@@?????@@@@@, ?@@@@@?????@@@@@ @@@
    787                  if (deviceState.mode) {
    788                      LCD_ShowString(10, 30, "mode : auto   ", BLACK, WHITE);
    789                  } else {
    790                      LCD_ShowString(10, 30, "mode : manual ", BLACK, WHITE);
   \                     ??main_1: (+1)
   \   00000036   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x....             LDR.N    R2,??DataTable20_30
   \   00000040   0x211E             MOVS     R1,#+30
   \   00000042   0x200A             MOVS     R0,#+10
   \   00000044   0x.... 0x....      BL       LCD_ShowString
   \   00000048   0xE015             B.N      ??main_2
    791                  }
   \                     ??main_3: (+1)
   \   0000004A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x2300             MOVS     R3,#+0
   \   00000052   0x....             LDR.N    R2,??DataTable20_31
   \   00000054   0x210A             MOVS     R1,#+10
   \   00000056   0x200A             MOVS     R0,#+10
   \   00000058   0x.... 0x....      BL       LCD_ShowString
   \                     ??main_4: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable20_18
   \   0000005E   0x7900             LDRB     R0,[R0, #+4]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD0E8             BEQ.N    ??main_1
   \   00000064   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x....             LDR.N    R2,??DataTable20_32
   \   0000006E   0x211E             MOVS     R1,#+30
   \   00000070   0x200A             MOVS     R0,#+10
   \   00000072   0x.... 0x....      BL       LCD_ShowString
    792          
    793                  // ?@@@?@@@
    794                  sprintf(pBuffer, "Bright : %d   ", deviceState.light); // @@@ ?@@ @?@@@
   \                     ??main_2: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable20_18
   \   00000078   0x8842             LDRH     R2,[R0, #+2]
   \   0000007A   0x....             LDR.N    R1,??DataTable20_33
   \   0000007C   0xA801             ADD      R0,SP,#+4
   \   0000007E   0x.... 0x....      BL       sprintf
    795                  LCD_ShowString(10, 70, pBuffer, BLACK, WHITE);
                                                ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "u8 *"
   \   00000082   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000086   0x9000             STR      R0,[SP, #+0]
   \   00000088   0x2300             MOVS     R3,#+0
   \   0000008A   0xAA01             ADD      R2,SP,#+4
   \   0000008C   0x2146             MOVS     R1,#+70
   \   0000008E   0x200A             MOVS     R0,#+10
   \   00000090   0x.... 0x....      BL       LCD_ShowString
    796                  sprintf(pBuffer, "Soil moisture : %d   ", deviceState.soilMoisture); // ?@@ ?@@ ?@@ @?@@@
   \   00000094   0x....             LDR.N    R0,??DataTable20_18
   \   00000096   0x8802             LDRH     R2,[R0, #+0]
   \   00000098   0x....             LDR.N    R1,??DataTable20_34
   \   0000009A   0xA801             ADD      R0,SP,#+4
   \   0000009C   0x.... 0x....      BL       sprintf
    797                  LCD_ShowString(10, 90, pBuffer, BLACK, WHITE);
                                                ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "u8 *"
   \   000000A0   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000A4   0x9000             STR      R0,[SP, #+0]
   \   000000A6   0x2300             MOVS     R3,#+0
   \   000000A8   0xAA01             ADD      R2,SP,#+4
   \   000000AA   0x215A             MOVS     R1,#+90
   \   000000AC   0x200A             MOVS     R0,#+10
   \   000000AE   0x.... 0x....      BL       LCD_ShowString
    798                  
    799                  // esp32 @@@
    800                  sprintf(pBuffer, "isClose : %d   ", sensorState.isClose); // @@@ ?@@ @?@@@(esp32@?@€???@@??@?
   \   000000B2   0x....             LDR.N    R0,??DataTable20_19
   \   000000B4   0x7802             LDRB     R2,[R0, #+0]
   \   000000B6   0x....             LDR.N    R1,??DataTable20_35
   \   000000B8   0xA801             ADD      R0,SP,#+4
   \   000000BA   0x.... 0x....      BL       sprintf
    801                  LCD_ShowString(10, 110, pBuffer, BLACK, WHITE);
                                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "u8 *"
   \   000000BE   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x2300             MOVS     R3,#+0
   \   000000C6   0xAA01             ADD      R2,SP,#+4
   \   000000C8   0x216E             MOVS     R1,#+110
   \   000000CA   0x200A             MOVS     R0,#+10
   \   000000CC   0x.... 0x....      BL       LCD_ShowString
    802                  sprintf(pBuffer, "isEnough : %d   ", sensorState.isEnough); // ?@@ ?@@ @?@@@(esp32@?@€???@@??@?
   \   000000D0   0x....             LDR.N    R0,??DataTable20_19
   \   000000D2   0x7842             LDRB     R2,[R0, #+1]
   \   000000D4   0x....             LDR.N    R1,??DataTable20_36
   \   000000D6   0xA801             ADD      R0,SP,#+4
   \   000000D8   0x.... 0x....      BL       sprintf
    803                  LCD_ShowString(10, 130, pBuffer, BLACK, WHITE);
                                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "u8 *"
   \   000000DC   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000E0   0x9000             STR      R0,[SP, #+0]
   \   000000E2   0x2300             MOVS     R3,#+0
   \   000000E4   0xAA01             ADD      R2,SP,#+4
   \   000000E6   0x2182             MOVS     R1,#+130
   \   000000E8   0x200A             MOVS     R0,#+10
   \   000000EA   0x.... 0x....      BL       LCD_ShowString
    804                  
    805                  
    806                  // @@@??@@@(@@@?@@ @@@@?@€???@@??@@@??
    807                  sprintf(pBuffer, "Command : %s                                 ", usart1Buffer.mem);
   \   000000EE   0x....             LDR.N    R2,??DataTable20_16
   \   000000F0   0x....             LDR.N    R1,??DataTable20_37
   \   000000F2   0xA801             ADD      R0,SP,#+4
   \   000000F4   0x.... 0x....      BL       sprintf
    808                  LCD_ShowString(10, 170, pBuffer, BLACK, WHITE);
                                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "u8 *"
   \   000000F8   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000FC   0x9000             STR      R0,[SP, #+0]
   \   000000FE   0x2300             MOVS     R3,#+0
   \   00000100   0xAA01             ADD      R2,SP,#+4
   \   00000102   0x21AA             MOVS     R1,#+170
   \   00000104   0x200A             MOVS     R0,#+10
   \   00000106   0x.... 0x....      BL       LCD_ShowString
    809                  
    810                  // usart2@?json ?@@???@@
    811                  sendJsonToUART();
   \   0000010A   0x.... 0x....      BL       sendJsonToUART
   \                     ??main_0: (+1)
   \   0000010E   0x....             LDR.N    R0,??DataTable20_19
   \   00000110   0x7840             LDRB     R0,[R0, #+1]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD109             BNE.N    ??main_5
   \   00000116   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000011A   0x9000             STR      R0,[SP, #+0]
   \   0000011C   0x2300             MOVS     R3,#+0
   \   0000011E   0x....             LDR.N    R2,??DataTable20_38
   \   00000120   0x210A             MOVS     R1,#+10
   \   00000122   0x200A             MOVS     R0,#+10
   \   00000124   0x.... 0x....      BL       LCD_ShowString
   \   00000128   0xE798             B.N      ??main_4
   \                     ??main_5: (+1)
   \   0000012A   0x....             LDR.N    R0,??DataTable20_19
   \   0000012C   0x7880             LDRB     R0,[R0, #+2]
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD18B             BNE.N    ??main_3
   \   00000132   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000136   0x9000             STR      R0,[SP, #+0]
   \   00000138   0x2300             MOVS     R3,#+0
   \   0000013A   0x....             LDR.N    R2,??DataTable20_39
   \   0000013C   0x210A             MOVS     R1,#+10
   \   0000013E   0x200A             MOVS     R0,#+10
   \   00000140   0x.... 0x....      BL       LCD_ShowString
   \   00000144   0xE78A             B.N      ??main_4
    812                  // ?@@?
    813          
    814              }
    815          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     GPIO_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     NVIC_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     USART_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     ADC_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x40012800         DC32     0x40012800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x........         DC32     TIM_TimeBaseStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x........         DC32     TIM_OCInitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_14:
   \   00000000   0x........         DC32     EXTI_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_15:
   \   00000000   0x........         DC32     TIM_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_16:
   \   00000000   0x........         DC32     usart1Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_17:
   \   00000000   0x........         DC32     usart2Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_18:
   \   00000000   0x........         DC32     deviceState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_19:
   \   00000000   0x........         DC32     sensorState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_20:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_21:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_22:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_23:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_24:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_25:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_26:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_27:
   \   00000000   0x........         DC32     pumpState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_28:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_29:
   \   00000000   0x........         DC32     jsonBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_30:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_31:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_32:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_33:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_34:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_35:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_36:
   \   00000000   0x........         DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_37:
   \   00000000   0x........         DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_38:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_39:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x6D 0x6F          DC8 "mode 1"
   \              0x64 0x65    
   \              0x20 0x31    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x6D 0x6F          DC8 "mode 0"
   \              0x64 0x65    
   \              0x20 0x30    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x6C 0x65          DC8 "led 1"
   \              0x64 0x20    
   \              0x31 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x6C 0x65          DC8 "led 0"
   \              0x64 0x20    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x64 0x6F          DC8 "door 1"
   \              0x6F 0x72    
   \              0x20 0x31    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x64 0x6F          DC8 "door 0"
   \              0x6F 0x72    
   \              0x20 0x30    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x77 0x61          DC8 "water"
   \              0x74 0x65    
   \              0x72 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x7B 0x22          DC8 7BH, 22H, 6DH, 6FH, 64H, 65H, 22H, 3AH
   \              0x6D 0x6F    
   \              0x64 0x65    
   \              0x22 0x3A    
   \   00000008   0x25 0x64          DC8 25H, 64H, 2CH, 20H, 22H, 6CH, 65H, 64H
   \              0x2C 0x20    
   \              0x22 0x6C    
   \              0x65 0x64    
   \   00000010   0x22 0x3A          DC8 22H, 3AH, 25H, 64H, 2CH, 20H, 22H, 64H
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x22 0x64    
   \   00000018   0x6F 0x6F          DC8 6FH, 6FH, 72H, 22H, 3AH, 25H, 64H, 2CH
   \              0x72 0x22    
   \              0x3A 0x25    
   \              0x64 0x2C    
   \   00000020   0x20 0x22          DC8 20H, 22H, 73H, 6FH, 69H, 6CH, 22H, 3AH
   \              0x73 0x6F    
   \              0x69 0x6C    
   \              0x22 0x3A    
   \   00000028   0x25 0x64          DC8 25H, 64H, 2CH, 20H, 22H, 6CH, 69H, 67H
   \              0x2C 0x20    
   \              0x22 0x6C    
   \              0x69 0x67    
   \   00000030   0x68 0x74          DC8 68H, 74H, 22H, 3AH, 25H, 64H, 2CH, 20H
   \              0x22 0x3A    
   \              0x25 0x64    
   \              0x2C 0x20    
   \   00000038   0x22 0x6C          DC8 22H, 6CH, 65H, 76H, 65H, 6CH, 22H, 3AH
   \              0x65 0x76    
   \              0x65 0x6C    
   \              0x22 0x3A    
   \   00000040   0x25 0x64          DC8 25H, 64H, 7DH, 0DH, 0AH, 0
   \              0x7D 0x0D    
   \              0x0A 0x00    
   \   00000046   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x4E 0x65          DC8 "Need to supply water"
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x70 0x70    
   \              0x6C 0x79    
   \              0x20 0x77    
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x67 0x69          DC8 "give water to plant       "
   \              0x76 0x65    
   \              0x20 0x77    
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x70 0x6C    
   \              0x61 0x6E    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x47 0x6F          DC8 "Good condition            "
   \              0x6F 0x64    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x64 0x69    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x6D 0x6F          DC8 "mode : auto   "
   \              0x64 0x65    
   \              0x20 0x3A    
   \              0x20 0x61    
   \              0x75 0x74    
   \              0x6F 0x20    
   \              0x20 0x20    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x6D 0x6F          DC8 "mode : manual "
   \              0x64 0x65    
   \              0x20 0x3A    
   \              0x20 0x6D    
   \              0x61 0x6E    
   \              0x75 0x61    
   \              0x6C 0x20    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x42 0x72          DC8 "Bright : %d   "
   \              0x69 0x67    
   \              0x68 0x74    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x64 0x20    
   \              0x20 0x20    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x53 0x6F          DC8 "Soil moisture : %d   "
   \              0x69 0x6C    
   \              0x20 0x6D    
   \              0x6F 0x69    
   \              0x73 0x74    
   \              0x75 0x72    
   \              0x65 0x20    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x20 0x20    
   \              0x20 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x69 0x73          DC8 "isClose : %d   "
   \              0x43 0x6C    
   \              0x6F 0x73    
   \              0x65 0x20    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x20 0x20    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_16:
   \   00000000   0x69 0x73          DC8 "isEnough : %d   "
   \              0x45 0x6E    
   \              0x6F 0x75    
   \              0x67 0x68    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x64 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_17:
   \   00000000   0x43 0x6F          DC8 "Command : %s                                 "
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0
    816          /*
    817          -----------------------------------------------------------------------------------
    818          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ADC1_2_IRQHandler
         8   -> ADC_ClearITPendingBit
         8   -> ADC_GetConversionValue
         8   -> ADC_GetITStatus
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> controlLED
         8   -> controlPump
       8   EXTI1_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
         8   -> controlServo
       8   EXTI2_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
       8   NVIC_Config
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   TIM2_IRQHandler
         8   -> TIM_ClearITPendingBit
         8   -> TIM_Cmd
         8   -> TIM_GetITStatus
         8   -> controlPump
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> excuteCommand
         8   -> readBuffer
         8   -> resetIndex
       8   USART2_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> excuteCommand
         8   -> readBuffer
         8   -> resetIndex
       0   __NVIC_EnableIRQ
       8   adc_module_config
         8   -> ADC_Cmd
         8   -> ADC_GetCalibrationStatus
         8   -> ADC_GetResetCalibrationStatus
         8   -> ADC_ITConfig
         8   -> ADC_Init
         8   -> ADC_RegularChannelConfig
         8   -> ADC_ResetCalibration
         8   -> ADC_SoftwareStartConvCmd
         8   -> ADC_StartCalibration
         8   -> GPIO_Init
         8   -> RCC_APB2PeriphClockCmd
       8   controlLED
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   controlPump
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   controlServo
         8   -> TIM_OC1Init
         8   -> TIM_OC1PreloadConfig
       8   eps32_config
         8   -> EXTI_Init
         8   -> GPIO_EXTILineConfig
         8   -> GPIO_Init
         8   -> RCC_APB2PeriphClockCmd
         8   -> __NVIC_EnableIRQ
       8   excuteCommand
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> controlLED
         8   -> controlServo
         8   -> initialModules
         8   -> strcmp
         8   -> water
       8   initialModules
         8   -> controlLED
         8   -> controlPump
         8   -> controlServo
       8   led_config
         8   -> GPIO_Init
         8   -> RCC_APB2PeriphClockCmd
     408   main
       408   -> LCD_Clear
       408   -> LCD_Init
       408   -> LCD_ShowString
       408   -> NVIC_Config
       408   -> adc_module_config
       408   -> eps32_config
       408   -> initialModules
       408   -> led_config
       408   -> pump_config
       408   -> sendJsonToUART
       408   -> servo_config
       408   -> sprintf
       408   -> usart1_config
       408   -> usart2_config
       0   myDelay
       8   pump_config
         8   -> GPIO_Init
         8   -> GPIO_SetBits
         8   -> NVIC_Init
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
         8   -> TIM_ITConfig
         8   -> TIM_TimeBaseInit
         8   -> __NVIC_EnableIRQ
       0   readBuffer
       0   resetIndex
      24   sendJsonToUART
        24   -> USART_SendData
        24   -> myDelay
        24   -> sprintf
       8   servo_config
         8   -> GPIO_Init
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
         8   -> TIM_Cmd
         8   -> TIM_OC1Init
         8   -> TIM_OC1PreloadConfig
         8   -> TIM_TimeBaseInit
       8   usart1_config
         8   -> GPIO_Init
         8   -> RCC_APB2PeriphClockCmd
         8   -> USART_Cmd
         8   -> USART_ITConfig
         8   -> USART_Init
       8   usart2_config
         8   -> GPIO_Init
         8   -> GPIO_PinRemapConfig
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
         8   -> USART_Cmd
         8   -> USART_ITConfig
         8   -> USART_Init
       8   water
         8   -> TIM_Cmd
         8   -> controlPump


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_16
       4  ??DataTable20_17
       4  ??DataTable20_18
       4  ??DataTable20_19
       4  ??DataTable20_2
       4  ??DataTable20_20
       4  ??DataTable20_21
       4  ??DataTable20_22
       4  ??DataTable20_23
       4  ??DataTable20_24
       4  ??DataTable20_25
       4  ??DataTable20_26
       4  ??DataTable20_27
       4  ??DataTable20_28
       4  ??DataTable20_29
       4  ??DataTable20_3
       4  ??DataTable20_30
       4  ??DataTable20_31
       4  ??DataTable20_32
       4  ??DataTable20_33
       4  ??DataTable20_34
       4  ??DataTable20_35
       4  ??DataTable20_36
       4  ??DataTable20_37
       4  ??DataTable20_38
       4  ??DataTable20_39
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
       8  ?_0
       8  ?_1
      28  ?_10
      16  ?_11
      16  ?_12
      16  ?_13
      24  ?_14
      16  ?_15
      20  ?_16
      48  ?_17
       8  ?_2
       8  ?_3
       8  ?_4
       8  ?_5
       8  ?_6
      72  ?_7
      24  ?_8
      28  ?_9
     274  ADC1_2_IRQHandler
      20  ADC_InitStructure
     114  EXTI1_IRQHandler
      46  EXTI2_IRQHandler
       8  EXTI_InitStructure
       4  GPIO_InitStructure
     288  NVIC_Config
       4  NVIC_InitStructure
      44  TIM2_IRQHandler
      12  TIM_InitStructure
      16  TIM_OCInitStructure
      12  TIM_TimeBaseStructure
      82  USART1_IRQHandler
      82  USART2_IRQHandler
      16  USART_InitStructure
      30  __NVIC_EnableIRQ
     412  adc_module_config
      40  controlLED
      56  controlPump
      48  controlServo
       8  deviceState
     202  eps32_config
     232  excuteCommand
      24  initialModules
     204  jsonBuffer
      48  led_config
     326  main
      12  myDelay
       1  pumpState
     226  pump_config
      56  readBuffer
       8  resetIndex
      78  sendJsonToUART
       4  sensorState
     168  servo_config
     204  usart1Buffer
     192  usart1_config
     204  usart2Buffer
     196  usart2_config
      34  water

 
   717 bytes in section .bss
   364 bytes in section .rodata
 3 486 bytes in section .text
 
 3 486 bytes of CODE  memory
   364 bytes of CONST memory
   717 bytes of DATA  memory

Errors: none
Warnings: 5
