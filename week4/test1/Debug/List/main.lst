###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       16/Oct/2024  20:49:26
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\pnu8\Desktop\week3\test1\user\main.c
#    Command line =  
#        -f C:\Users\pnu8\AppData\Local\Temp\EW58BD.tmp
#        (C:\Users\pnu8\Desktop\week3\test1\user\main.c -D USE_STDPERIPH_DRIVER
#        -D STM32F10X_CL -lC C:\Users\pnu8\Desktop\week3\test1\Debug\List -o
#        C:\Users\pnu8\Desktop\week3\test1\Debug\Obj --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu8\Desktop\week3\test1\libraries\CMSIS\DeviceSupport\ -I
#        C:\Users\pnu8\Desktop\week3\test1\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu8\Desktop\week3\test1\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu8\Desktop\week3\test1\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu8\Desktop\week3\test1\user\ -I
#        C:\Users\pnu8\Desktop\week3\test1\user\inc\ -Ol -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  C:\Users\pnu8\Desktop\week3\test1\Debug\List\main.lst
#    Object file  =  C:\Users\pnu8\Desktop\week3\test1\Debug\Obj\main.o
#
###############################################################################

C:\Users\pnu8\Desktop\week3\test1\user\main.c
      1          
      2          #include "stm32f10x.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000E   0x408A             LSLS     R2,R2,R1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0xe000e100
   \   00000014   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000016   0x0940             LSRS     R0,R0,#+5
   \   00000018   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
      3          #include "stm32f10x_exti.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_usart.h"
      6          #include "stm32f10x_rcc.h"
      7          
      8          #include "misc.h"
      9          
     10          /* function prototype */
     11          void RCC_Configure(void);
     12          void GPIO_Configure(void);
     13          void EXTI_Configure(void);
     14          void USART1_Init(void);
     15          void NVIC_Configure(void);
     16          
     17          void EXTI15_10_IRQHandler(void);
     18          
     19          void Delay(void);
     20          
     21          void sendDataUART1(uint16_t data);
     22          

   \                                 In section .bss, align 4
     23          int mode = 0; // default @@@
   \                     mode:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     24          int idx = 0; 
   \                     idx:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
     25          char msg[] = "Team08\r\n";
   \                     msg:
   \   00000000   0x54 0x65          DC8 "Team08\015\012"
   \              0x61 0x6D    
   \              0x30 0x38    
   \              0x0D 0x0A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     26          
     27          //---------------------------------------------------------------------------------------------------
     28          

   \                                 In section .text, align 2, keep-with-next
     29          void RCC_Configure(void)
     30          {
   \                     RCC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     31          	// TODO: Enable the APB2 peripheral clock using the function 'RCC_APB2PeriphClockCmd'
     32          	
     33          	/* UART TX/RX port clock enable */
     34              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //rx, tx@ PA@ @
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     35          	/* Button S1, S2, S3 port clock enable */
     36          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); // S1, S2, S3@ PB, PC@ @
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     37              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     38          	/* LED port clock enable */
     39          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     40          	/* USART1 clock enable */
     41          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF44F 0x4080      MOV      R0,#+16384
   \   00000028   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     42          	/* Alternate Function IO clock enable */
     43          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     44          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
     45          

   \                                 In section .text, align 2, keep-with-next
     46          void GPIO_Configure(void)
     47          {
   \                     GPIO_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     48              GPIO_InitTypeDef GPIO_InitStructure;
     49              // Button S1, S2, S3 port KEY 1 : PC4 /  KEY 2 : PB10 /  KEY 1 : PC 13
     50              // rx : PA10, tx : PA9
     51          	// TODO: Initialize the GPIO pins using the structure 'GPIO_InitTypeDef' and the function 'GPIO_Init'
     52          	
     53              /* Button S1, S2, S3 pin setting */
     54              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000002   0xF44F 0x6080      MOV      R0,#+1024
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     55              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU | GPIO_Mode_IPD; // pull up@ down@@ @@
                                                  ^
Warning[Pe188]: enumerated type mixed with another type
   \   0000000A   0x2068             MOVS     R0,#+104
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     56              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40010c00
   \   00000014   0x.... 0x....      BL       GPIO_Init
     57          
     58              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_13;
   \   00000018   0xF242 0x0010      MOVW     R0,#+8208
   \   0000001C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     59              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU | GPIO_Mode_IPD; // pull up@ down@@ @@
                                                  ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000020   0x2068             MOVS     R0,#+104
   \   00000022   0xF88D 0x0003      STRB     R0,[SP, #+3]
     60              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40011000
   \   0000002A   0x.... 0x....      BL       GPIO_Init
     61              
     62              /* LED pin setting*/
     63              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7;
   \   0000002E   0x209C             MOVS     R0,#+156
   \   00000030   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     64              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0xF88D 0x0002      STRB     R0,[SP, #+2]
     65              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000003A   0x2010             MOVS     R0,#+16
   \   0000003C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     66              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40011400
   \   00000044   0x.... 0x....      BL       GPIO_Init
     67          	
     68              /* UART pin setting */
     69              //TX
     70              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   00000048   0xF44F 0x7000      MOV      R0,#+512
   \   0000004C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     71              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // tx@ Alternate function output Push-pull@ @@
   \   00000050   0x2018             MOVS     R0,#+24
   \   00000052   0xF88D 0x0003      STRB     R0,[SP, #+3]
     72              GPIO_Init(GPIOA, &GPIO_InitStructure); // @@ @@@ @@@ @@@@@!!
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40010800
   \   0000005A   0x.... 0x....      BL       GPIO_Init
     73          	//RX
     74              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000005E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000062   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     75              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU | GPIO_Mode_IPD; // rx@ Input with pull-up / pull-down@@ @@
                                                  ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000066   0x2068             MOVS     R0,#+104
   \   00000068   0xF88D 0x0003      STRB     R0,[SP, #+3]
     76              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000006C   0x4669             MOV      R1,SP
   \   0000006E   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40010800
   \   00000070   0x.... 0x....      BL       GPIO_Init
     77          	
     78          }
   \   00000074   0xBD01             POP      {R0,PC}          ;; return
     79          

   \                                 In section .text, align 2, keep-with-next
     80          void EXTI_Configure(void)
     81          {
   \                     EXTI_Configure: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
     82              EXTI_InitTypeDef EXTI_InitStructure;
     83          
     84          	// TODO: Select the GPIO pin (Joystick, button) used as EXTI Line using function 'GPIO_EXTILineConfig'
     85          	// TODO: Initialize the EXTI using the structure 'EXTI_InitTypeDef' and the function 'EXTI_Init'
     86          	// Button S1, S2, S3 port KEY 1 : PC4 /  KEY 2 : PB10 /  KEY 1 : PC 13
     87              /* Button S1 */
     88          	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource4);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      BL       GPIO_EXTILineConfig
     89              EXTI_InitStructure.EXTI_Line = EXTI_Line4;
   \   0000000A   0x2010             MOVS     R0,#+16
   \   0000000C   0x9000             STR      R0,[SP, #+0]
     90              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0004      STRB     R0,[SP, #+4]
     91              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   00000014   0x200C             MOVS     R0,#+12
   \   00000016   0xF88D 0x0005      STRB     R0,[SP, #+5]
     92              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF88D 0x0006      STRB     R0,[SP, #+6]
     93              EXTI_Init(&EXTI_InitStructure);
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       EXTI_Init
     94          
     95              /* Button S2 */
     96          	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource10);
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       GPIO_EXTILineConfig
     97              EXTI_InitStructure.EXTI_Line = EXTI_Line10;
   \   0000002E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000032   0x9000             STR      R0,[SP, #+0]
     98              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0004      STRB     R0,[SP, #+4]
     99              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   0000003A   0x200C             MOVS     R0,#+12
   \   0000003C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    100              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0006      STRB     R0,[SP, #+6]
    101              EXTI_Init(&EXTI_InitStructure);
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x.... 0x....      BL       EXTI_Init
    102          
    103          	/* Button S3 */
    104              GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
   \   0000004C   0x210D             MOVS     R1,#+13
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0x.... 0x....      BL       GPIO_EXTILineConfig
    105              EXTI_InitStructure.EXTI_Line = EXTI_Line13;
   \   00000054   0xF44F 0x5000      MOV      R0,#+8192
   \   00000058   0x9000             STR      R0,[SP, #+0]
    106              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    107              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   00000060   0x200C             MOVS     R0,#+12
   \   00000062   0xF88D 0x0005      STRB     R0,[SP, #+5]
    108              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF88D 0x0006      STRB     R0,[SP, #+6]
    109              EXTI_Init(&EXTI_InitStructure);
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x.... 0x....      BL       EXTI_Init
    110              //@@@ Line@@@@!!
    111          	// NOTE: do not select the UART GPIO pin used as EXTI Line here
    112          }
   \   00000072   0xBD07             POP      {R0-R2,PC}       ;; return
    113          

   \                                 In section .text, align 2, keep-with-next
    114          void USART1_Init(void)
    115          {
   \                     USART1_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    116          	USART_InitTypeDef USART1_InitStructure;
    117          
    118          	// Enable the USART1 peripheral
    119          	USART_Cmd(USART1, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40013800
   \   00000006   0x.... 0x....      BL       USART_Cmd
    120          	
    121          	// TODO: Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    122          	USART1_InitStructure.USART_BaudRate = 9600;
   \   0000000A   0xF44F 0x5016      MOV      R0,#+9600
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    123              USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    124              USART1_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    125              USART1_InitStructure.USART_Parity = USART_Parity_No;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    126              //USART1_InitStructure.USART_Mode = 
    127              USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    128              USART1_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000028   0x200C             MOVS     R0,#+12
   \   0000002A   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    129               // usart @@@ @@@ @@
    130          
    131              USART_Init(USART1,&USART1_InitStructure);
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40013800
   \   00000032   0x.... 0x....      BL       USART_Init
    132          	
    133          	// TODO: Enable the USART1 RX interrupts using the function 'USART_ITConfig' and the argument value 'Receive Data register not empty interrupt'
    134          	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0xF240 0x5125      MOVW     R1,#+1317
   \   0000003C   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40013800
   \   0000003E   0x.... 0x....      BL       USART_ITConfig
    135              // RXNE = rx not empty kya~
    136          }
   \   00000042   0xB005             ADD      SP,SP,#+20
   \   00000044   0xBD00             POP      {PC}             ;; return
    137          

   \                                 In section .text, align 2, keep-with-next
    138          void NVIC_Configure(void) {
   \                     NVIC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    139          
    140              NVIC_InitTypeDef NVIC_InitStructure;
    141              
    142              // TODO: fill the arg you want
    143              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 
   \   00000002   0xF44F 0x60A0      MOV      R0,#+1280
   \   00000006   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    144          
    145          	// TODO: Initialize the NVIC using the structure 'NVIC_InitTypeDef' and the function 'NVIC_Init'
    146          	//@@ @@@;;
    147              // Button S1
    148              NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
   \   0000000A   0x200A             MOVS     R0,#+10
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    149              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; // TODO
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xF88D 0x0001      STRB     R0,[SP, #+1]
    150              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // TODO
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0002      STRB     R0,[SP, #+2]
    151              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    152              NVIC_Init(&NVIC_InitStructure);
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x.... 0x....      BL       NVIC_Init
    153          
    154              // Button S2, S3
    155              NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \   00000028   0x2028             MOVS     R0,#+40
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    156              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // TODO
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0001      STRB     R0,[SP, #+1]
    157              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // TODO
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0002      STRB     R0,[SP, #+2]
    158              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    159              NVIC_Init(&NVIC_InitStructure);
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x.... 0x....      BL       NVIC_Init
    160          
    161              // UART1
    162          	// 'NVIC_EnableIRQ' is only required for USART setting
    163              NVIC_EnableIRQ(USART1_IRQn);
   \   00000046   0x2025             MOVS     R0,#+37
   \   00000048   0x.... 0x....      BL       __NVIC_EnableIRQ
    164              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   0000004C   0x2025             MOVS     R0,#+37
   \   0000004E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    165              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // TODO
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF88D 0x0001      STRB     R0,[SP, #+1]
    166              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // TODO
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    167              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xF88D 0x0003      STRB     R0,[SP, #+3]
    168              NVIC_Init(&NVIC_InitStructure);
   \   00000064   0x4668             MOV      R0,SP
   \   00000066   0x.... 0x....      BL       NVIC_Init
    169          }
   \   0000006A   0xBD01             POP      {R0,PC}          ;; return
    170          

   \                                 In section .text, align 2, keep-with-next
    171          void USART1_IRQHandler() {
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    172          	uint16_t word;
    173              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){ // GetITStatus@ @@@@ @@ @@ @@@@
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40013800
   \   00000008   0x.... 0x....      BL       USART_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD015             BEQ.N    ??USART1_IRQHandler_0
    174              	// the most recent received data by the USART1 peripheral
    175                  word = USART_ReceiveData(USART1);
   \   00000010   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40013800
   \   00000012   0x.... 0x....      BL       USART_ReceiveData
    176          
    177                  // TODO implement
    178                  if (word == 'a') {
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0x2961             CMP      R1,#+97
   \   0000001C   0xD103             BNE.N    ??USART1_IRQHandler_1
    179                      mode = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable8_6
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0xE005             B.N      ??USART1_IRQHandler_2
    180                  }
    181          
    182                  else if (word == 'b') {
   \                     ??USART1_IRQHandler_1: (+1)
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0x2862             CMP      R0,#+98
   \   0000002A   0xD102             BNE.N    ??USART1_IRQHandler_2
    183                      mode = 1;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable8_6
   \   00000030   0x6008             STR      R0,[R1, #+0]
    184                  }
    185                  
    186                  // clear 'Read data register not empty' flag
    187              	USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \                     ??USART1_IRQHandler_2: (+1)
   \   00000032   0xF240 0x5125      MOVW     R1,#+1317
   \   00000036   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40013800
   \   00000038   0x.... 0x....      BL       USART_ClearITPendingBit
    188              }
    189          }
   \                     ??USART1_IRQHandler_0: (+1)
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
    190          

   \                                 In section .text, align 2, keep-with-next
    191          void EXTI15_10_IRQHandler(void) { // when the button is pressed
   \                     EXTI15_10_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    192          
    193              if (EXTI_GetITStatus(EXTI_Line10) != RESET) { // key2
   \   00000002   0xF44F 0x6080      MOV      R0,#+1024
   \   00000006   0x.... 0x....      BL       EXTI_GetITStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00D             BEQ.N    ??EXTI15_10_IRQHandler_0
    194          		if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_10) == Bit_RESET) {
   \   0000000E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000012   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40010c00
   \   00000014   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD102             BNE.N    ??EXTI15_10_IRQHandler_1
    195          			// TODO implement
    196                      mode = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR.N    R1,??DataTable8_6
   \   00000020   0x6008             STR      R0,[R1, #+0]
    197          		}
    198          		EXTI_ClearITPendingBit(EXTI_Line10);
   \                     ??EXTI15_10_IRQHandler_1: (+1)
   \   00000022   0xF44F 0x6080      MOV      R0,#+1024
   \   00000026   0x.... 0x....      BL       EXTI_ClearITPendingBit
    199          	}
    200              if (EXTI_GetITStatus(EXTI_Line13) != RESET) { // key3
   \                     ??EXTI15_10_IRQHandler_0: (+1)
   \   0000002A   0xF44F 0x5000      MOV      R0,#+8192
   \   0000002E   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD015             BEQ.N    ??EXTI15_10_IRQHandler_2
    201          		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == Bit_RESET) {
   \   00000036   0xF44F 0x5100      MOV      R1,#+8192
   \   0000003A   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40011000
   \   0000003C   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD10A             BNE.N    ??EXTI15_10_IRQHandler_3
    202          			// TODO implement
    203                      int i = 0;
   \   00000044   0x2000             MOVS     R0,#+0
    204                      for(i=0; i<14; i++){
   \   00000046   0x2400             MOVS     R4,#+0
   \   00000048   0xE005             B.N      ??EXTI15_10_IRQHandler_4
    205                          sendDataUART1(msg[i]);
   \                     ??EXTI15_10_IRQHandler_5: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable8_7
   \   0000004C   0x5D00             LDRB     R0,[R0, R4]
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0x.... 0x....      BL       sendDataUART1
    206                      }     
   \   00000054   0x1C64             ADDS     R4,R4,#+1
   \                     ??EXTI15_10_IRQHandler_4: (+1)
   \   00000056   0x2C0E             CMP      R4,#+14
   \   00000058   0xDBF7             BLT.N    ??EXTI15_10_IRQHandler_5
    207          		}
    208                  EXTI_ClearITPendingBit(EXTI_Line13);
   \                     ??EXTI15_10_IRQHandler_3: (+1)
   \   0000005A   0xF44F 0x5000      MOV      R0,#+8192
   \   0000005E   0x.... 0x....      BL       EXTI_ClearITPendingBit
    209          	}
    210          }
   \                     ??EXTI15_10_IRQHandler_2: (+1)
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    211          
    212          // TODO: Create Joystick interrupt handler functions

   \                                 In section .text, align 2, keep-with-next
    213          void EXTI4_IRQHandler(void) {
   \                     EXTI4_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    214              if (EXTI_GetITStatus(EXTI_Line4) != RESET) { // key1
   \   00000002   0x2010             MOVS     R0,#+16
   \   00000004   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00B             BEQ.N    ??EXTI4_IRQHandler_0
    215          		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_4) == Bit_RESET) {
   \   0000000C   0x2110             MOVS     R1,#+16
   \   0000000E   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40011000
   \   00000010   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD102             BNE.N    ??EXTI4_IRQHandler_1
    216          			// TODO implement
    217                      mode = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable8_6
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    218          		}
    219          		EXTI_ClearITPendingBit(EXTI_Line4);
   \                     ??EXTI4_IRQHandler_1: (+1)
   \   0000001E   0x2010             MOVS     R0,#+16
   \   00000020   0x.... 0x....      BL       EXTI_ClearITPendingBit
    220          	}
    221          }
   \                     ??EXTI4_IRQHandler_0: (+1)
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    222          

   \                                 In section .text, align 2, keep-with-next
    223          void Delay(void) {
    224          	int i;
    225          
    226          	for (i = 0; i < 2000000; i++) {}
   \                     Delay: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE000             B.N      ??Delay_0
   \                     ??Delay_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??Delay_0: (+1)
   \   00000006   0x....             LDR.N    R1,??DataTable8_8  ;; 0x1e8480
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xDBFB             BLT.N    ??Delay_1
    227          }
   \   0000000C   0x4770             BX       LR               ;; return
    228          

   \                                 In section .text, align 2, keep-with-next
    229          void sendDataUART1(uint16_t data) {
   \                     sendDataUART1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    230          	/* Wait till TC is set */
    231          	while ((USART1->SR & USART_SR_TC) == 0);
   \                     ??sendDataUART1_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40013800
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x0640             LSLS     R0,R0,#+25
   \   0000000A   0xD5FB             BPL.N    ??sendDataUART1_0
    232          	USART_SendData(USART1, data);
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40013800
   \   00000010   0x.... 0x....      BL       USART_SendData
    233          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    234          

   \                                 In section .text, align 2, keep-with-next
    235          int main(void)
    236          {
   \                     main: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    237          
    238              SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    239          
    240              RCC_Configure();
   \   00000006   0x.... 0x....      BL       RCC_Configure
    241          
    242              GPIO_Configure();
   \   0000000A   0x.... 0x....      BL       GPIO_Configure
    243          
    244              EXTI_Configure();
   \   0000000E   0x.... 0x....      BL       EXTI_Configure
    245          
    246              USART1_Init();
   \   00000012   0x.... 0x....      BL       USART1_Init
    247          
    248              NVIC_Configure();
   \   00000016   0x.... 0x....      BL       NVIC_Configure
    249              
    250              unsigned led_array[4] = {
    251                GPIO_Pin_2,
    252                GPIO_Pin_3,
    253                GPIO_Pin_4,
    254                GPIO_Pin_7,
    255              };
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x....             LDR.N    R1,??DataTable8_9
   \   0000001E   0x2210             MOVS     R2,#+16
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000024   0xE01E             B.N      ??main_0
    256          
    257              while (1) {
    258              	// TODO: implement 
    259                  idx = (idx + 4) % 4;
    260                  for (int i = 0; i < 4; ++i) {
    261                    if (i == idx) {
    262                       GPIO_ResetBits(GPIOD, led_array[i]);
    263                    } else {
    264                      GPIO_SetBits(GPIOD, led_array[i]);
    265                    }
    266                  }
    267          
    268                  if(mode) {
    269                      idx--;
    270                  }
    271                  else {
    272                      idx++;
   \                     ??main_1: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable8_10
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x....             LDR.N    R1,??DataTable8_10
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE016             B.N      ??main_2
    273                  }
   \                     ??main_3: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable8_10
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD120             BNE.N    ??main_4
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   00000040   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000042   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40011400
   \   00000044   0x.... 0x....      BL       GPIO_ResetBits
   \                     ??main_5: (+1)
   \   00000048   0x1C64             ADDS     R4,R4,#+1
   \                     ??main_6: (+1)
   \   0000004A   0x2C04             CMP      R4,#+4
   \   0000004C   0xDBF1             BLT.N    ??main_3
   \                     ??main_7: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable8_6
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD0E7             BEQ.N    ??main_1
   \   00000056   0x....             LDR.N    R0,??DataTable8_10
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x1E40             SUBS     R0,R0,#+1
   \   0000005C   0x....             LDR.N    R1,??DataTable8_10
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    274              	// Delay
    275              	Delay();
   \                     ??main_2: (+1)
   \   00000060   0x.... 0x....      BL       Delay
   \                     ??main_0: (+1)
   \   00000064   0x....             LDR.N    R0,??DataTable8_10
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x1D00             ADDS     R0,R0,#+4
   \   0000006A   0x2104             MOVS     R1,#+4
   \   0000006C   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000070   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000074   0x....             LDR.N    R1,??DataTable8_10
   \   00000076   0x6008             STR      R0,[R1, #+0]
   \   00000078   0x2400             MOVS     R4,#+0
   \   0000007A   0xE7E6             B.N      ??main_6
   \                     ??main_4: (+1)
   \   0000007C   0x4668             MOV      R0,SP
   \   0000007E   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   00000082   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000084   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40011400
   \   00000086   0x.... 0x....      BL       GPIO_SetBits
   \   0000008A   0xE7DD             B.N      ??main_5
    276                  
    277          
    278          
    279              }
    280              return 0;
                     ^
Warning[Pe111]: statement is unreachable
    281          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     mode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     msg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     idx

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x00000004         DC32 4, 8, 16, 128
   \              0x00000008   
   \              0x00000010   
   \              0x00000080   

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Delay
       8   EXTI15_10_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
         8   -> sendDataUART1
       8   EXTI4_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
      16   EXTI_Configure
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
       8   GPIO_Configure
         8   -> GPIO_Init
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCC_Configure
         8   -> RCC_APB2PeriphClockCmd
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   __NVIC_EnableIRQ
      24   main
        24   -> Delay
        24   -> EXTI_Configure
        24   -> GPIO_Configure
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> NVIC_Configure
        24   -> RCC_Configure
        24   -> SystemInit
        24   -> USART1_Init
        24   -> __aeabi_memcpy4
       8   sendDataUART1
         8   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      16  ?_0
      14  Delay
     100  EXTI15_10_IRQHandler
      38  EXTI4_IRQHandler
     116  EXTI_Configure
     118  GPIO_Configure
     108  NVIC_Configure
      54  RCC_Configure
      62  USART1_IRQHandler
      70  USART1_Init
      30  __NVIC_EnableIRQ
       4  idx
     140  main
       4  mode
      12  msg
      22  sendDataUART1

 
   8 bytes in section .bss
  12 bytes in section .data
  16 bytes in section .rodata
 916 bytes in section .text
 
 916 bytes of CODE  memory
  16 bytes of CONST memory
  20 bytes of DATA  memory

Errors: none
Warnings: 4
